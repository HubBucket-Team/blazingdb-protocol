// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TREE_PLAN_TREE_H_
#define FLATBUFFERS_GENERATED_TREE_PLAN_TREE_H_

#include "flatbuffers/flatbuffers.h"

namespace plan {
namespace tree {

struct Child;
struct ChildT;

struct TableScanNode;
struct TableScanNodeT;

struct ProjectNode;
struct ProjectNodeT;

struct AggregateNode;
struct AggregateNodeT;

struct UnionNode;
struct UnionNodeT;

struct RootNode;
struct RootNodeT;

enum NodeType {
  NodeType_Project = 0,
  NodeType_Filter = 1,
  NodeType_TableScan = 2,
  NodeType_Aggregate = 3,
  NodeType_Union = 4,
  NodeType_MIN = NodeType_Project,
  NodeType_MAX = NodeType_Union
};

inline const NodeType (&EnumValuesNodeType())[5] {
  static const NodeType values[] = {
    NodeType_Project,
    NodeType_Filter,
    NodeType_TableScan,
    NodeType_Aggregate,
    NodeType_Union
  };
  return values;
}

inline const char * const *EnumNamesNodeType() {
  static const char * const names[] = {
    "Project",
    "Filter",
    "TableScan",
    "Aggregate",
    "Union",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesNodeType()[index];
}

struct ChildT : public flatbuffers::NativeTable {
  typedef Child TableType;
  NodeType type;
  std::vector<uint8_t> data;
  ChildT()
      : type(NodeType_Project) {
  }
};

struct Child FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChildT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_DATA = 6
  };
  NodeType type() const {
    return static_cast<NodeType>(GetField<uint16_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
  ChildT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ChildT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Child> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ChildT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChildBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(NodeType type) {
    fbb_.AddElement<uint16_t>(Child::VT_TYPE, static_cast<uint16_t>(type), 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Child::VT_DATA, data);
  }
  explicit ChildBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChildBuilder &operator=(const ChildBuilder &);
  flatbuffers::Offset<Child> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Child>(end);
    return o;
  }
};

inline flatbuffers::Offset<Child> CreateChild(
    flatbuffers::FlatBufferBuilder &_fbb,
    NodeType type = NodeType_Project,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  ChildBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Child> CreateChildDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    NodeType type = NodeType_Project,
    const std::vector<uint8_t> *data = nullptr) {
  return plan::tree::CreateChild(
      _fbb,
      type,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

flatbuffers::Offset<Child> CreateChild(flatbuffers::FlatBufferBuilder &_fbb, const ChildT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TableScanNodeT : public flatbuffers::NativeTable {
  typedef TableScanNode TableType;
  std::vector<std::string> tablePath;
  TableScanNodeT() {
  }
};

struct TableScanNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableScanNodeT NativeTableType;
  enum {
    VT_TABLEPATH = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tablePath() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TABLEPATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TABLEPATH) &&
           verifier.Verify(tablePath()) &&
           verifier.VerifyVectorOfStrings(tablePath()) &&
           verifier.EndTable();
  }
  TableScanNodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TableScanNodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TableScanNode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TableScanNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TableScanNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tablePath(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tablePath) {
    fbb_.AddOffset(TableScanNode::VT_TABLEPATH, tablePath);
  }
  explicit TableScanNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableScanNodeBuilder &operator=(const TableScanNodeBuilder &);
  flatbuffers::Offset<TableScanNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableScanNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableScanNode> CreateTableScanNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tablePath = 0) {
  TableScanNodeBuilder builder_(_fbb);
  builder_.add_tablePath(tablePath);
  return builder_.Finish();
}

inline flatbuffers::Offset<TableScanNode> CreateTableScanNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tablePath = nullptr) {
  return plan::tree::CreateTableScanNode(
      _fbb,
      tablePath ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tablePath) : 0);
}

flatbuffers::Offset<TableScanNode> CreateTableScanNode(flatbuffers::FlatBufferBuilder &_fbb, const TableScanNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProjectNodeT : public flatbuffers::NativeTable {
  typedef ProjectNode TableType;
  std::vector<std::string> columnNames;
  std::vector<std::string> columnValues;
  std::vector<std::unique_ptr<ChildT>> children;
  ProjectNodeT() {
  }
};

struct ProjectNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProjectNodeT NativeTableType;
  enum {
    VT_COLUMNNAMES = 4,
    VT_COLUMNVALUES = 6,
    VT_CHILDREN = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNNAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnValues() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNVALUES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Child>> *children() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Child>> *>(VT_CHILDREN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLUMNNAMES) &&
           verifier.Verify(columnNames()) &&
           verifier.VerifyVectorOfStrings(columnNames()) &&
           VerifyOffset(verifier, VT_COLUMNVALUES) &&
           verifier.Verify(columnValues()) &&
           verifier.VerifyVectorOfStrings(columnValues()) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.Verify(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           verifier.EndTable();
  }
  ProjectNodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProjectNodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProjectNode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProjectNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProjectNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_columnNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames) {
    fbb_.AddOffset(ProjectNode::VT_COLUMNNAMES, columnNames);
  }
  void add_columnValues(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnValues) {
    fbb_.AddOffset(ProjectNode::VT_COLUMNVALUES, columnValues);
  }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Child>>> children) {
    fbb_.AddOffset(ProjectNode::VT_CHILDREN, children);
  }
  explicit ProjectNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectNodeBuilder &operator=(const ProjectNodeBuilder &);
  flatbuffers::Offset<ProjectNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProjectNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProjectNode> CreateProjectNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnValues = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Child>>> children = 0) {
  ProjectNodeBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_columnValues(columnValues);
  builder_.add_columnNames(columnNames);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProjectNode> CreateProjectNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnNames = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnValues = nullptr,
    const std::vector<flatbuffers::Offset<Child>> *children = nullptr) {
  return plan::tree::CreateProjectNode(
      _fbb,
      columnNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnNames) : 0,
      columnValues ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnValues) : 0,
      children ? _fbb.CreateVector<flatbuffers::Offset<Child>>(*children) : 0);
}

flatbuffers::Offset<ProjectNode> CreateProjectNode(flatbuffers::FlatBufferBuilder &_fbb, const ProjectNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AggregateNodeT : public flatbuffers::NativeTable {
  typedef AggregateNode TableType;
  std::vector<int64_t> groups;
  std::vector<std::unique_ptr<ChildT>> children;
  AggregateNodeT() {
  }
};

struct AggregateNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AggregateNodeT NativeTableType;
  enum {
    VT_GROUPS = 4,
    VT_CHILDREN = 6
  };
  const flatbuffers::Vector<int64_t> *groups() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_GROUPS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Child>> *children() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Child>> *>(VT_CHILDREN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GROUPS) &&
           verifier.Verify(groups()) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.Verify(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           verifier.EndTable();
  }
  AggregateNodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AggregateNodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AggregateNode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AggregateNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AggregateNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_groups(flatbuffers::Offset<flatbuffers::Vector<int64_t>> groups) {
    fbb_.AddOffset(AggregateNode::VT_GROUPS, groups);
  }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Child>>> children) {
    fbb_.AddOffset(AggregateNode::VT_CHILDREN, children);
  }
  explicit AggregateNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AggregateNodeBuilder &operator=(const AggregateNodeBuilder &);
  flatbuffers::Offset<AggregateNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AggregateNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<AggregateNode> CreateAggregateNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> groups = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Child>>> children = 0) {
  AggregateNodeBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_groups(groups);
  return builder_.Finish();
}

inline flatbuffers::Offset<AggregateNode> CreateAggregateNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *groups = nullptr,
    const std::vector<flatbuffers::Offset<Child>> *children = nullptr) {
  return plan::tree::CreateAggregateNode(
      _fbb,
      groups ? _fbb.CreateVector<int64_t>(*groups) : 0,
      children ? _fbb.CreateVector<flatbuffers::Offset<Child>>(*children) : 0);
}

flatbuffers::Offset<AggregateNode> CreateAggregateNode(flatbuffers::FlatBufferBuilder &_fbb, const AggregateNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnionNodeT : public flatbuffers::NativeTable {
  typedef UnionNode TableType;
  bool all;
  std::vector<std::unique_ptr<ChildT>> children;
  UnionNodeT()
      : all(false) {
  }
};

struct UnionNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnionNodeT NativeTableType;
  enum {
    VT_ALL = 4,
    VT_CHILDREN = 6
  };
  bool all() const {
    return GetField<uint8_t>(VT_ALL, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Child>> *children() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Child>> *>(VT_CHILDREN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALL) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.Verify(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           verifier.EndTable();
  }
  UnionNodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnionNodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnionNode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnionNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_all(bool all) {
    fbb_.AddElement<uint8_t>(UnionNode::VT_ALL, static_cast<uint8_t>(all), 0);
  }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Child>>> children) {
    fbb_.AddOffset(UnionNode::VT_CHILDREN, children);
  }
  explicit UnionNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnionNodeBuilder &operator=(const UnionNodeBuilder &);
  flatbuffers::Offset<UnionNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnionNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnionNode> CreateUnionNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool all = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Child>>> children = 0) {
  UnionNodeBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_all(all);
  return builder_.Finish();
}

inline flatbuffers::Offset<UnionNode> CreateUnionNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool all = false,
    const std::vector<flatbuffers::Offset<Child>> *children = nullptr) {
  return plan::tree::CreateUnionNode(
      _fbb,
      all,
      children ? _fbb.CreateVector<flatbuffers::Offset<Child>>(*children) : 0);
}

flatbuffers::Offset<UnionNode> CreateUnionNode(flatbuffers::FlatBufferBuilder &_fbb, const UnionNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RootNodeT : public flatbuffers::NativeTable {
  typedef RootNode TableType;
  std::vector<std::unique_ptr<ChildT>> children;
  RootNodeT() {
  }
};

struct RootNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RootNodeT NativeTableType;
  enum {
    VT_CHILDREN = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Child>> *children() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Child>> *>(VT_CHILDREN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.Verify(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           verifier.EndTable();
  }
  RootNodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RootNodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RootNode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RootNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RootNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Child>>> children) {
    fbb_.AddOffset(RootNode::VT_CHILDREN, children);
  }
  explicit RootNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RootNodeBuilder &operator=(const RootNodeBuilder &);
  flatbuffers::Offset<RootNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RootNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<RootNode> CreateRootNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Child>>> children = 0) {
  RootNodeBuilder builder_(_fbb);
  builder_.add_children(children);
  return builder_.Finish();
}

inline flatbuffers::Offset<RootNode> CreateRootNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Child>> *children = nullptr) {
  return plan::tree::CreateRootNode(
      _fbb,
      children ? _fbb.CreateVector<flatbuffers::Offset<Child>>(*children) : 0);
}

flatbuffers::Offset<RootNode> CreateRootNode(flatbuffers::FlatBufferBuilder &_fbb, const RootNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ChildT *Child::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ChildT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Child::UnPackTo(ChildT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Child> Child::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ChildT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChild(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Child> CreateChild(flatbuffers::FlatBufferBuilder &_fbb, const ChildT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ChildT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return plan::tree::CreateChild(
      _fbb,
      _type,
      _data);
}

inline TableScanNodeT *TableScanNode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TableScanNodeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TableScanNode::UnPackTo(TableScanNodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tablePath(); if (_e) { _o->tablePath.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tablePath[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<TableScanNode> TableScanNode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TableScanNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTableScanNode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TableScanNode> CreateTableScanNode(flatbuffers::FlatBufferBuilder &_fbb, const TableScanNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TableScanNodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tablePath = _o->tablePath.size() ? _fbb.CreateVectorOfStrings(_o->tablePath) : 0;
  return plan::tree::CreateTableScanNode(
      _fbb,
      _tablePath);
}

inline ProjectNodeT *ProjectNode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProjectNodeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ProjectNode::UnPackTo(ProjectNodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = columnNames(); if (_e) { _o->columnNames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->columnNames[_i] = _e->Get(_i)->str(); } } };
  { auto _e = columnValues(); if (_e) { _o->columnValues.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->columnValues[_i] = _e->Get(_i)->str(); } } };
  { auto _e = children(); if (_e) { _o->children.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->children[_i] = std::unique_ptr<ChildT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<ProjectNode> ProjectNode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProjectNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProjectNode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProjectNode> CreateProjectNode(flatbuffers::FlatBufferBuilder &_fbb, const ProjectNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProjectNodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _columnNames = _o->columnNames.size() ? _fbb.CreateVectorOfStrings(_o->columnNames) : 0;
  auto _columnValues = _o->columnValues.size() ? _fbb.CreateVectorOfStrings(_o->columnValues) : 0;
  auto _children = _o->children.size() ? _fbb.CreateVector<flatbuffers::Offset<Child>> (_o->children.size(), [](size_t i, _VectorArgs *__va) { return CreateChild(*__va->__fbb, __va->__o->children[i].get(), __va->__rehasher); }, &_va ) : 0;
  return plan::tree::CreateProjectNode(
      _fbb,
      _columnNames,
      _columnValues,
      _children);
}

inline AggregateNodeT *AggregateNode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AggregateNodeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AggregateNode::UnPackTo(AggregateNodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = groups(); if (_e) { _o->groups.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->groups[_i] = _e->Get(_i); } } };
  { auto _e = children(); if (_e) { _o->children.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->children[_i] = std::unique_ptr<ChildT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<AggregateNode> AggregateNode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AggregateNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAggregateNode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AggregateNode> CreateAggregateNode(flatbuffers::FlatBufferBuilder &_fbb, const AggregateNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AggregateNodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _groups = _o->groups.size() ? _fbb.CreateVector(_o->groups) : 0;
  auto _children = _o->children.size() ? _fbb.CreateVector<flatbuffers::Offset<Child>> (_o->children.size(), [](size_t i, _VectorArgs *__va) { return CreateChild(*__va->__fbb, __va->__o->children[i].get(), __va->__rehasher); }, &_va ) : 0;
  return plan::tree::CreateAggregateNode(
      _fbb,
      _groups,
      _children);
}

inline UnionNodeT *UnionNode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnionNodeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnionNode::UnPackTo(UnionNodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = all(); _o->all = _e; };
  { auto _e = children(); if (_e) { _o->children.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->children[_i] = std::unique_ptr<ChildT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<UnionNode> UnionNode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnionNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnionNode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnionNode> CreateUnionNode(flatbuffers::FlatBufferBuilder &_fbb, const UnionNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnionNodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _all = _o->all;
  auto _children = _o->children.size() ? _fbb.CreateVector<flatbuffers::Offset<Child>> (_o->children.size(), [](size_t i, _VectorArgs *__va) { return CreateChild(*__va->__fbb, __va->__o->children[i].get(), __va->__rehasher); }, &_va ) : 0;
  return plan::tree::CreateUnionNode(
      _fbb,
      _all,
      _children);
}

inline RootNodeT *RootNode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RootNodeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RootNode::UnPackTo(RootNodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = children(); if (_e) { _o->children.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->children[_i] = std::unique_ptr<ChildT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<RootNode> RootNode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RootNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRootNode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RootNode> CreateRootNode(flatbuffers::FlatBufferBuilder &_fbb, const RootNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RootNodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _children = _o->children.size() ? _fbb.CreateVector<flatbuffers::Offset<Child>> (_o->children.size(), [](size_t i, _VectorArgs *__va) { return CreateChild(*__va->__fbb, __va->__o->children[i].get(), __va->__rehasher); }, &_va ) : 0;
  return plan::tree::CreateRootNode(
      _fbb,
      _children);
}

inline const plan::tree::RootNode *GetRootNode(const void *buf) {
  return flatbuffers::GetRoot<plan::tree::RootNode>(buf);
}

inline const plan::tree::RootNode *GetSizePrefixedRootNode(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<plan::tree::RootNode>(buf);
}

inline bool VerifyRootNodeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<plan::tree::RootNode>(nullptr);
}

inline bool VerifySizePrefixedRootNodeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<plan::tree::RootNode>(nullptr);
}

inline void FinishRootNodeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<plan::tree::RootNode> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRootNodeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<plan::tree::RootNode> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<RootNodeT> UnPackRootNode(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<RootNodeT>(GetRootNode(buf)->UnPack(res));
}

}  // namespace tree
}  // namespace plan

#endif  // FLATBUFFERS_GENERATED_TREE_PLAN_TREE_H_
