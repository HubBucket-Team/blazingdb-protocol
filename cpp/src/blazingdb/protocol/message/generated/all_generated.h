// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ALL_H_
#define FLATBUFFERS_GENERATED_ALL_H_

#include "flatbuffers/flatbuffers.h"

namespace blazingdb {
namespace protocol {
namespace calcite {

struct DMLRequest;

struct DDLRequest;

struct DDLCreateTableRequest;

struct DDLDropTableRequest;

}  // namespace calcite

namespace orchestrator {

struct DDLCreateTableRequest;

struct DDLDropTableRequest;

struct AuthRequest;

}  // namespace orchestrator

namespace gdf {

struct gdf_dtype_extra_info;

struct cudaIpcMemHandle_t;

struct gdf_column_handler;

}  // namespace gdf

struct BlazingTable;

struct TableGroup;

namespace orchestrator {

struct DMLRequest;

struct DDLRequest;

}  // namespace orchestrator

namespace interpreter {

struct DMLRequest;

struct GetResultRequest;

}  // namespace interpreter

struct Header;

struct Request;

}  // namespace protocol
}  // namespace blazingdb

namespace com {
namespace blazingdb {
namespace protocol {
namespace calcite {
namespace plan {
namespace messages {

struct TableScan;

struct LogicalProject;

struct LogicalAggregate;

struct LogicalUnion;

struct RelNode;

struct RexCall;

struct RexInputRef;

struct RexLiteral;

struct RexNode;

}  // namespace messages
}  // namespace plan
}  // namespace calcite
}  // namespace protocol
}  // namespace blazingdb
}  // namespace com

namespace blazingdb {
namespace protocol {
namespace calcite {

struct DMLResponse;

struct DDLResponse;

}  // namespace calcite

namespace orchestrator {

struct AuthResponse;

}  // namespace orchestrator

struct NodeConnection;

namespace orchestrator {

struct DMLResponse;

struct DDLResponse;

}  // namespace orchestrator

namespace interpreter {

struct ExecutePlanResponse;

struct BlazingMetadata;

struct GetResultResponse;

}  // namespace interpreter

struct Response;

struct ResponseError;

namespace calcite {

enum MessageType {
  MessageType_DDL = 0,
  MessageType_DML = 1,
  MessageType_DDL_CREATE_TABLE = 2,
  MessageType_DDL_DROP_TABLE = 3,
  MessageType_MIN = MessageType_DDL,
  MessageType_MAX = MessageType_DDL_DROP_TABLE
};

inline const MessageType (&EnumValuesMessageType())[4] {
  static const MessageType values[] = {
    MessageType_DDL,
    MessageType_DML,
    MessageType_DDL_CREATE_TABLE,
    MessageType_DDL_DROP_TABLE
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[] = {
    "DDL",
    "DML",
    "DDL_CREATE_TABLE",
    "DDL_DROP_TABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageType()[index];
}

}  // namespace calcite

namespace orchestrator {

enum MessageType {
  MessageType_DDL = 0,
  MessageType_DML = 1,
  MessageType_DDL_CREATE_TABLE = 2,
  MessageType_DDL_DROP_TABLE = 3,
  MessageType_AuthOpen = 4,
  MessageType_AuthClose = 5,
  MessageType_MIN = MessageType_DDL,
  MessageType_MAX = MessageType_AuthClose
};

inline const MessageType (&EnumValuesMessageType())[6] {
  static const MessageType values[] = {
    MessageType_DDL,
    MessageType_DML,
    MessageType_DDL_CREATE_TABLE,
    MessageType_DDL_DROP_TABLE,
    MessageType_AuthOpen,
    MessageType_AuthClose
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[] = {
    "DDL",
    "DML",
    "DDL_CREATE_TABLE",
    "DDL_DROP_TABLE",
    "AuthOpen",
    "AuthClose",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageType()[index];
}

}  // namespace orchestrator

namespace gdf {

enum gdf_dtype {
  gdf_dtype_GDF_invalid = 0,
  gdf_dtype_GDF_INT8 = 1,
  gdf_dtype_GDF_INT16 = 2,
  gdf_dtype_GDF_INT32 = 3,
  gdf_dtype_GDF_INT64 = 4,
  gdf_dtype_GDF_UINT8 = 5,
  gdf_dtype_GDF_UINT16 = 6,
  gdf_dtype_GDF_UINT32 = 7,
  gdf_dtype_GDF_UINT64 = 8,
  gdf_dtype_GDF_FLOAT32 = 9,
  gdf_dtype_GDF_FLOAT64 = 10,
  gdf_dtype_GDF_DATE32 = 11,
  gdf_dtype_GDF_DATE64 = 12,
  gdf_dtype_GDF_TIMESTAMP = 13,
  gdf_dtype_N_GDF_TYPES = 14,
  gdf_dtype_MIN = gdf_dtype_GDF_invalid,
  gdf_dtype_MAX = gdf_dtype_N_GDF_TYPES
};

inline const gdf_dtype (&EnumValuesgdf_dtype())[15] {
  static const gdf_dtype values[] = {
    gdf_dtype_GDF_invalid,
    gdf_dtype_GDF_INT8,
    gdf_dtype_GDF_INT16,
    gdf_dtype_GDF_INT32,
    gdf_dtype_GDF_INT64,
    gdf_dtype_GDF_UINT8,
    gdf_dtype_GDF_UINT16,
    gdf_dtype_GDF_UINT32,
    gdf_dtype_GDF_UINT64,
    gdf_dtype_GDF_FLOAT32,
    gdf_dtype_GDF_FLOAT64,
    gdf_dtype_GDF_DATE32,
    gdf_dtype_GDF_DATE64,
    gdf_dtype_GDF_TIMESTAMP,
    gdf_dtype_N_GDF_TYPES
  };
  return values;
}

inline const char * const *EnumNamesgdf_dtype() {
  static const char * const names[] = {
    "GDF_invalid",
    "GDF_INT8",
    "GDF_INT16",
    "GDF_INT32",
    "GDF_INT64",
    "GDF_UINT8",
    "GDF_UINT16",
    "GDF_UINT32",
    "GDF_UINT64",
    "GDF_FLOAT32",
    "GDF_FLOAT64",
    "GDF_DATE32",
    "GDF_DATE64",
    "GDF_TIMESTAMP",
    "N_GDF_TYPES",
    nullptr
  };
  return names;
}

inline const char *EnumNamegdf_dtype(gdf_dtype e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesgdf_dtype()[index];
}

enum gdf_time_unit {
  gdf_time_unit_TIME_UNIT_NONE = 0,
  gdf_time_unit_TIME_UNIT_s = 1,
  gdf_time_unit_TIME_UNIT_ms = 2,
  gdf_time_unit_TIME_UNIT_us = 3,
  gdf_time_unit_TIME_UNIT_ns = 4,
  gdf_time_unit_MIN = gdf_time_unit_TIME_UNIT_NONE,
  gdf_time_unit_MAX = gdf_time_unit_TIME_UNIT_ns
};

inline const gdf_time_unit (&EnumValuesgdf_time_unit())[5] {
  static const gdf_time_unit values[] = {
    gdf_time_unit_TIME_UNIT_NONE,
    gdf_time_unit_TIME_UNIT_s,
    gdf_time_unit_TIME_UNIT_ms,
    gdf_time_unit_TIME_UNIT_us,
    gdf_time_unit_TIME_UNIT_ns
  };
  return values;
}

inline const char * const *EnumNamesgdf_time_unit() {
  static const char * const names[] = {
    "TIME_UNIT_NONE",
    "TIME_UNIT_s",
    "TIME_UNIT_ms",
    "TIME_UNIT_us",
    "TIME_UNIT_ns",
    nullptr
  };
  return names;
}

inline const char *EnumNamegdf_time_unit(gdf_time_unit e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesgdf_time_unit()[index];
}

}  // namespace gdf

namespace interpreter {

enum MessageType {
  MessageType_ExecutePlan = 0,
  MessageType_GetResult = 1,
  MessageType_FreeResult = 2,
  MessageType_CloseConnection = 3,
  MessageType_MIN = MessageType_ExecutePlan,
  MessageType_MAX = MessageType_CloseConnection
};

inline const MessageType (&EnumValuesMessageType())[4] {
  static const MessageType values[] = {
    MessageType_ExecutePlan,
    MessageType_GetResult,
    MessageType_FreeResult,
    MessageType_CloseConnection
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[] = {
    "ExecutePlan",
    "GetResult",
    "FreeResult",
    "CloseConnection",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageType()[index];
}

}  // namespace interpreter
}  // namespace protocol
}  // namespace blazingdb

namespace com {
namespace blazingdb {
namespace protocol {
namespace calcite {
namespace plan {
namespace messages {

enum RelNodeType {
  RelNodeType_Root = 0,
  RelNodeType_LogicalProject = 1,
  RelNodeType_LogicalFilter = 2,
  RelNodeType_TableScan = 3,
  RelNodeType_LogicalAggregate = 4,
  RelNodeType_LogicalUnion = 5,
  RelNodeType_MIN = RelNodeType_Root,
  RelNodeType_MAX = RelNodeType_LogicalUnion
};

inline const RelNodeType (&EnumValuesRelNodeType())[6] {
  static const RelNodeType values[] = {
    RelNodeType_Root,
    RelNodeType_LogicalProject,
    RelNodeType_LogicalFilter,
    RelNodeType_TableScan,
    RelNodeType_LogicalAggregate,
    RelNodeType_LogicalUnion
  };
  return values;
}

inline const char * const *EnumNamesRelNodeType() {
  static const char * const names[] = {
    "Root",
    "LogicalProject",
    "LogicalFilter",
    "TableScan",
    "LogicalAggregate",
    "LogicalUnion",
    nullptr
  };
  return names;
}

inline const char *EnumNameRelNodeType(RelNodeType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRelNodeType()[index];
}

enum RexNodeType {
  RexNodeType_Root = 0,
  RexNodeType_Call = 1,
  RexNodeType_CorrelVariable = 2,
  RexNodeType_DynamicParam = 3,
  RexNodeType_FieldAccess = 4,
  RexNodeType_InputRef = 5,
  RexNodeType_Literal = 6,
  RexNodeType_LocalRef = 7,
  RexNodeType_Over = 8,
  RexNodeType_PatternFieldRef = 9,
  RexNodeType_RangeRef = 10,
  RexNodeType_SubQuery = 11,
  RexNodeType_TableInputRef = 12,
  RexNodeType_Variable = 13,
  RexNodeType_MIN = RexNodeType_Root,
  RexNodeType_MAX = RexNodeType_Variable
};

inline const RexNodeType (&EnumValuesRexNodeType())[14] {
  static const RexNodeType values[] = {
    RexNodeType_Root,
    RexNodeType_Call,
    RexNodeType_CorrelVariable,
    RexNodeType_DynamicParam,
    RexNodeType_FieldAccess,
    RexNodeType_InputRef,
    RexNodeType_Literal,
    RexNodeType_LocalRef,
    RexNodeType_Over,
    RexNodeType_PatternFieldRef,
    RexNodeType_RangeRef,
    RexNodeType_SubQuery,
    RexNodeType_TableInputRef,
    RexNodeType_Variable
  };
  return values;
}

inline const char * const *EnumNamesRexNodeType() {
  static const char * const names[] = {
    "Root",
    "Call",
    "CorrelVariable",
    "DynamicParam",
    "FieldAccess",
    "InputRef",
    "Literal",
    "LocalRef",
    "Over",
    "PatternFieldRef",
    "RangeRef",
    "SubQuery",
    "TableInputRef",
    "Variable",
    nullptr
  };
  return names;
}

inline const char *EnumNameRexNodeType(RexNodeType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRexNodeType()[index];
}

enum SqlKind {
  SqlKind_OTHER = 0,
  SqlKind_SELECT = 1,
  SqlKind_JOIN = 2,
  SqlKind_IDENTIFIER = 3,
  SqlKind_LITERAL = 4,
  SqlKind_OTHER_FUNCTION = 5,
  SqlKind_EXPLAIN = 6,
  SqlKind_DESCRIBE_SCHEMA = 7,
  SqlKind_DESCRIBE_TABLE = 8,
  SqlKind_INSERT = 9,
  SqlKind_DELETE = 10,
  SqlKind_UPDATE = 11,
  SqlKind_SET_OPTION = 12,
  SqlKind_DYNAMIC_PARAM = 13,
  SqlKind_ORDER_BY = 14,
  SqlKind_WITH = 15,
  SqlKind_WITH_ITEM = 16,
  SqlKind_UNION = 17,
  SqlKind_EXCEPT = 18,
  SqlKind_INTERSECT = 19,
  SqlKind_AS = 20,
  SqlKind_ARGUMENT_ASSIGNMENT = 21,
  SqlKind_DEFAULT = 22,
  SqlKind_OVER = 23,
  SqlKind_FILTER = 24,
  SqlKind_WINDOW = 25,
  SqlKind_MERGE = 26,
  SqlKind_TABLESAMPLE = 27,
  SqlKind_MATCH_RECOGNIZE = 28,
  SqlKind_TIMES = 29,
  SqlKind_DIVIDE = 30,
  SqlKind_MOD = 31,
  SqlKind_PLUS = 32,
  SqlKind_MINUS = 33,
  SqlKind_PATTERN_ALTER = 34,
  SqlKind_PATTERN_CONCAT = 35,
  SqlKind_IN = 36,
  SqlKind_NOT_IN = 37,
  SqlKind_LESS_THAN = 38,
  SqlKind_GREATER_THAN = 39,
  SqlKind_LESS_THAN_OR_EQUAL = 40,
  SqlKind_GREATER_THAN_OR_EQUAL = 41,
  SqlKind_EQUALS = 42,
  SqlKind_NOT_EQUALS = 43,
  SqlKind_IS_DISTINCT_FROM = 44,
  SqlKind_IS_NOT_DISTINCT_FROM = 45,
  SqlKind_OR = 46,
  SqlKind_AND = 47,
  SqlKind_DOT = 48,
  SqlKind_OVERLAPS = 49,
  SqlKind_CONTAINS = 50,
  SqlKind_PRECEDES = 51,
  SqlKind_IMMEDIATELY_PRECEDES = 52,
  SqlKind_SUCCEEDS = 53,
  SqlKind_IMMEDIATELY_SUCCEEDS = 54,
  SqlKind_PERIOD_EQUALS = 55,
  SqlKind_LIKE = 56,
  SqlKind_SIMILAR = 57,
  SqlKind_BETWEEN = 58,
  SqlKind_CASE = 59,
  SqlKind_NULLIF = 60,
  SqlKind_COALESCE = 61,
  SqlKind_DECODE = 62,
  SqlKind_NVL = 63,
  SqlKind_GREATEST = 64,
  SqlKind_LEAST = 65,
  SqlKind_TIMESTAMP_ADD = 66,
  SqlKind_TIMESTAMP_DIFF = 67,
  SqlKind_NOT = 68,
  SqlKind_PLUS_PREFIX = 69,
  SqlKind_MINUS_PREFIX = 70,
  SqlKind_EXISTS = 71,
  SqlKind_SOME = 72,
  SqlKind_ALL = 73,
  SqlKind_VALUES = 74,
  SqlKind_EXPLICIT_TABLE = 75,
  SqlKind_SCALAR_QUERY = 76,
  SqlKind_PROCEDURE_CALL = 77,
  SqlKind_NEW_SPECIFICATION = 78,
  SqlKind_FINAL = 79,
  SqlKind_RUNNING = 80,
  SqlKind_PREV = 81,
  SqlKind_NEXT = 82,
  SqlKind_FIRST = 83,
  SqlKind_LAST = 84,
  SqlKind_CLASSIFIER = 85,
  SqlKind_MATCH_NUMBER = 86,
  SqlKind_SKIP_TO_FIRST = 87,
  SqlKind_SKIP_TO_LAST = 88,
  SqlKind_DESCENDING = 89,
  SqlKind_NULLS_FIRST = 90,
  SqlKind_NULLS_LAST = 91,
  SqlKind_IS_TRUE = 92,
  SqlKind_IS_FALSE = 93,
  SqlKind_IS_NOT_TRUE = 94,
  SqlKind_IS_NOT_FALSE = 95,
  SqlKind_IS_UNKNOWN = 96,
  SqlKind_IS_NULL = 97,
  SqlKind_IS_NOT_NULL = 98,
  SqlKind_PRECEDING = 99,
  SqlKind_FOLLOWING = 100,
  SqlKind_FIELD_ACCESS = 101,
  SqlKind_INPUT_REF = 102,
  SqlKind_TABLE_INPUT_REF = 103,
  SqlKind_PATTERN_INPUT_REF = 104,
  SqlKind_LOCAL_REF = 105,
  SqlKind_CORREL_VARIABLE = 106,
  SqlKind_PATTERN_QUANTIFIER = 107,
  SqlKind_ROW = 108,
  SqlKind_COLUMN_LIST = 109,
  SqlKind_CAST = 110,
  SqlKind_NEXT_VALUE = 111,
  SqlKind_CURRENT_VALUE = 112,
  SqlKind_FLOOR = 113,
  SqlKind_CEIL = 114,
  SqlKind_TRIM = 115,
  SqlKind_LTRIM = 116,
  SqlKind_RTRIM = 117,
  SqlKind_EXTRACT = 118,
  SqlKind_JDBC_FN = 119,
  SqlKind_MULTISET_VALUE_CONSTRUCTOR = 120,
  SqlKind_MULTISET_QUERY_CONSTRUCTOR = 121,
  SqlKind_UNNEST = 122,
  SqlKind_LATERAL = 123,
  SqlKind_COLLECTION_TABLE = 124,
  SqlKind_ARRAY_VALUE_CONSTRUCTOR = 125,
  SqlKind_ARRAY_QUERY_CONSTRUCTOR = 126,
  SqlKind_MAP_VALUE_CONSTRUCTOR = 127,
  SqlKind_MAP_QUERY_CONSTRUCTOR = 128,
  SqlKind_CURSOR = 129,
  SqlKind_LITERAL_CHAIN = 130,
  SqlKind_ESCAPE = 131,
  SqlKind_REINTERPRET = 132,
  SqlKind_EXTEND = 133,
  SqlKind_CUBE = 134,
  SqlKind_ROLLUP = 135,
  SqlKind_GROUPING_SETS = 136,
  SqlKind_GROUPING = 137,
  SqlKind_GROUPING_ID = 138,
  SqlKind_GROUP_ID = 139,
  SqlKind_PATTERN_PERMUTE = 140,
  SqlKind_PATTERN_EXCLUDED = 141,
  SqlKind_COUNT = 142,
  SqlKind_SUM = 143,
  SqlKind_SUM0 = 144,
  SqlKind_MIN = 145,
  SqlKind_MAX = 146,
  SqlKind_LEAD = 147,
  SqlKind_LAG = 148,
  SqlKind_FIRST_VALUE = 149,
  SqlKind_LAST_VALUE = 150,
  SqlKind_ANY_VALUE = 151,
  SqlKind_COVAR_POP = 152,
  SqlKind_COVAR_SAMP = 153,
  SqlKind_REGR_COUNT = 154,
  SqlKind_REGR_SXX = 155,
  SqlKind_REGR_SYY = 156,
  SqlKind_AVG = 157,
  SqlKind_STDDEV_POP = 158,
  SqlKind_STDDEV_SAMP = 159,
  SqlKind_VAR_POP = 160,
  SqlKind_VAR_SAMP = 161,
  SqlKind_NTILE = 162,
  SqlKind_NTH_VALUE = 163,
  SqlKind_COLLECT = 164,
  SqlKind_FUSION = 165,
  SqlKind_SINGLE_VALUE = 166,
  SqlKind_ROW_NUMBER = 167,
  SqlKind_RANK = 168,
  SqlKind_PERCENT_RANK = 169,
  SqlKind_DENSE_RANK = 170,
  SqlKind_CUME_DIST = 171,
  SqlKind_TUMBLE = 172,
  SqlKind_TUMBLE_START = 173,
  SqlKind_TUMBLE_END = 174,
  SqlKind_HOP = 175,
  SqlKind_HOP_START = 176,
  SqlKind_HOP_END = 177,
  SqlKind_SESSION = 178,
  SqlKind_SESSION_START = 179,
  SqlKind_SESSION_END = 180,
  SqlKind_COLUMN_DECL = 181,
  SqlKind_ATTRIBUTE_DEF = 182,
  SqlKind_CHECK = 183,
  SqlKind_UNIQUE = 184,
  SqlKind_PRIMARY_KEY = 185,
  SqlKind_FOREIGN_KEY = 186,
  SqlKind_COMMIT = 187,
  SqlKind_ROLLBACK = 188,
  SqlKind_ALTER_SESSION = 189,
  SqlKind_CREATE_SCHEMA = 190,
  SqlKind_CREATE_FOREIGN_SCHEMA = 191,
  SqlKind_DROP_SCHEMA = 192,
  SqlKind_CREATE_TABLE = 193,
  SqlKind_ALTER_TABLE = 194,
  SqlKind_DROP_TABLE = 195,
  SqlKind_CREATE_VIEW = 196,
  SqlKind_ALTER_VIEW = 197,
  SqlKind_DROP_VIEW = 198,
  SqlKind_CREATE_MATERIALIZED_VIEW = 199,
  SqlKind_ALTER_MATERIALIZED_VIEW = 200,
  SqlKind_DROP_MATERIALIZED_VIEW = 201,
  SqlKind_CREATE_SEQUENCE = 202,
  SqlKind_ALTER_SEQUENCE = 203,
  SqlKind_DROP_SEQUENCE = 204,
  SqlKind_CREATE_INDEX = 205,
  SqlKind_ALTER_INDEX = 206,
  SqlKind_DROP_INDEX = 207,
  SqlKind_CREATE_TYPE = 208,
  SqlKind_DROP_TYPE = 209,
  SqlKind_OTHER_DDL = 210,
};

inline const SqlKind (&EnumValuesSqlKind())[211] {
  static const SqlKind values[] = {
    SqlKind_OTHER,
    SqlKind_SELECT,
    SqlKind_JOIN,
    SqlKind_IDENTIFIER,
    SqlKind_LITERAL,
    SqlKind_OTHER_FUNCTION,
    SqlKind_EXPLAIN,
    SqlKind_DESCRIBE_SCHEMA,
    SqlKind_DESCRIBE_TABLE,
    SqlKind_INSERT,
    SqlKind_DELETE,
    SqlKind_UPDATE,
    SqlKind_SET_OPTION,
    SqlKind_DYNAMIC_PARAM,
    SqlKind_ORDER_BY,
    SqlKind_WITH,
    SqlKind_WITH_ITEM,
    SqlKind_UNION,
    SqlKind_EXCEPT,
    SqlKind_INTERSECT,
    SqlKind_AS,
    SqlKind_ARGUMENT_ASSIGNMENT,
    SqlKind_DEFAULT,
    SqlKind_OVER,
    SqlKind_FILTER,
    SqlKind_WINDOW,
    SqlKind_MERGE,
    SqlKind_TABLESAMPLE,
    SqlKind_MATCH_RECOGNIZE,
    SqlKind_TIMES,
    SqlKind_DIVIDE,
    SqlKind_MOD,
    SqlKind_PLUS,
    SqlKind_MINUS,
    SqlKind_PATTERN_ALTER,
    SqlKind_PATTERN_CONCAT,
    SqlKind_IN,
    SqlKind_NOT_IN,
    SqlKind_LESS_THAN,
    SqlKind_GREATER_THAN,
    SqlKind_LESS_THAN_OR_EQUAL,
    SqlKind_GREATER_THAN_OR_EQUAL,
    SqlKind_EQUALS,
    SqlKind_NOT_EQUALS,
    SqlKind_IS_DISTINCT_FROM,
    SqlKind_IS_NOT_DISTINCT_FROM,
    SqlKind_OR,
    SqlKind_AND,
    SqlKind_DOT,
    SqlKind_OVERLAPS,
    SqlKind_CONTAINS,
    SqlKind_PRECEDES,
    SqlKind_IMMEDIATELY_PRECEDES,
    SqlKind_SUCCEEDS,
    SqlKind_IMMEDIATELY_SUCCEEDS,
    SqlKind_PERIOD_EQUALS,
    SqlKind_LIKE,
    SqlKind_SIMILAR,
    SqlKind_BETWEEN,
    SqlKind_CASE,
    SqlKind_NULLIF,
    SqlKind_COALESCE,
    SqlKind_DECODE,
    SqlKind_NVL,
    SqlKind_GREATEST,
    SqlKind_LEAST,
    SqlKind_TIMESTAMP_ADD,
    SqlKind_TIMESTAMP_DIFF,
    SqlKind_NOT,
    SqlKind_PLUS_PREFIX,
    SqlKind_MINUS_PREFIX,
    SqlKind_EXISTS,
    SqlKind_SOME,
    SqlKind_ALL,
    SqlKind_VALUES,
    SqlKind_EXPLICIT_TABLE,
    SqlKind_SCALAR_QUERY,
    SqlKind_PROCEDURE_CALL,
    SqlKind_NEW_SPECIFICATION,
    SqlKind_FINAL,
    SqlKind_RUNNING,
    SqlKind_PREV,
    SqlKind_NEXT,
    SqlKind_FIRST,
    SqlKind_LAST,
    SqlKind_CLASSIFIER,
    SqlKind_MATCH_NUMBER,
    SqlKind_SKIP_TO_FIRST,
    SqlKind_SKIP_TO_LAST,
    SqlKind_DESCENDING,
    SqlKind_NULLS_FIRST,
    SqlKind_NULLS_LAST,
    SqlKind_IS_TRUE,
    SqlKind_IS_FALSE,
    SqlKind_IS_NOT_TRUE,
    SqlKind_IS_NOT_FALSE,
    SqlKind_IS_UNKNOWN,
    SqlKind_IS_NULL,
    SqlKind_IS_NOT_NULL,
    SqlKind_PRECEDING,
    SqlKind_FOLLOWING,
    SqlKind_FIELD_ACCESS,
    SqlKind_INPUT_REF,
    SqlKind_TABLE_INPUT_REF,
    SqlKind_PATTERN_INPUT_REF,
    SqlKind_LOCAL_REF,
    SqlKind_CORREL_VARIABLE,
    SqlKind_PATTERN_QUANTIFIER,
    SqlKind_ROW,
    SqlKind_COLUMN_LIST,
    SqlKind_CAST,
    SqlKind_NEXT_VALUE,
    SqlKind_CURRENT_VALUE,
    SqlKind_FLOOR,
    SqlKind_CEIL,
    SqlKind_TRIM,
    SqlKind_LTRIM,
    SqlKind_RTRIM,
    SqlKind_EXTRACT,
    SqlKind_JDBC_FN,
    SqlKind_MULTISET_VALUE_CONSTRUCTOR,
    SqlKind_MULTISET_QUERY_CONSTRUCTOR,
    SqlKind_UNNEST,
    SqlKind_LATERAL,
    SqlKind_COLLECTION_TABLE,
    SqlKind_ARRAY_VALUE_CONSTRUCTOR,
    SqlKind_ARRAY_QUERY_CONSTRUCTOR,
    SqlKind_MAP_VALUE_CONSTRUCTOR,
    SqlKind_MAP_QUERY_CONSTRUCTOR,
    SqlKind_CURSOR,
    SqlKind_LITERAL_CHAIN,
    SqlKind_ESCAPE,
    SqlKind_REINTERPRET,
    SqlKind_EXTEND,
    SqlKind_CUBE,
    SqlKind_ROLLUP,
    SqlKind_GROUPING_SETS,
    SqlKind_GROUPING,
    SqlKind_GROUPING_ID,
    SqlKind_GROUP_ID,
    SqlKind_PATTERN_PERMUTE,
    SqlKind_PATTERN_EXCLUDED,
    SqlKind_COUNT,
    SqlKind_SUM,
    SqlKind_SUM0,
    SqlKind_MIN,
    SqlKind_MAX,
    SqlKind_LEAD,
    SqlKind_LAG,
    SqlKind_FIRST_VALUE,
    SqlKind_LAST_VALUE,
    SqlKind_ANY_VALUE,
    SqlKind_COVAR_POP,
    SqlKind_COVAR_SAMP,
    SqlKind_REGR_COUNT,
    SqlKind_REGR_SXX,
    SqlKind_REGR_SYY,
    SqlKind_AVG,
    SqlKind_STDDEV_POP,
    SqlKind_STDDEV_SAMP,
    SqlKind_VAR_POP,
    SqlKind_VAR_SAMP,
    SqlKind_NTILE,
    SqlKind_NTH_VALUE,
    SqlKind_COLLECT,
    SqlKind_FUSION,
    SqlKind_SINGLE_VALUE,
    SqlKind_ROW_NUMBER,
    SqlKind_RANK,
    SqlKind_PERCENT_RANK,
    SqlKind_DENSE_RANK,
    SqlKind_CUME_DIST,
    SqlKind_TUMBLE,
    SqlKind_TUMBLE_START,
    SqlKind_TUMBLE_END,
    SqlKind_HOP,
    SqlKind_HOP_START,
    SqlKind_HOP_END,
    SqlKind_SESSION,
    SqlKind_SESSION_START,
    SqlKind_SESSION_END,
    SqlKind_COLUMN_DECL,
    SqlKind_ATTRIBUTE_DEF,
    SqlKind_CHECK,
    SqlKind_UNIQUE,
    SqlKind_PRIMARY_KEY,
    SqlKind_FOREIGN_KEY,
    SqlKind_COMMIT,
    SqlKind_ROLLBACK,
    SqlKind_ALTER_SESSION,
    SqlKind_CREATE_SCHEMA,
    SqlKind_CREATE_FOREIGN_SCHEMA,
    SqlKind_DROP_SCHEMA,
    SqlKind_CREATE_TABLE,
    SqlKind_ALTER_TABLE,
    SqlKind_DROP_TABLE,
    SqlKind_CREATE_VIEW,
    SqlKind_ALTER_VIEW,
    SqlKind_DROP_VIEW,
    SqlKind_CREATE_MATERIALIZED_VIEW,
    SqlKind_ALTER_MATERIALIZED_VIEW,
    SqlKind_DROP_MATERIALIZED_VIEW,
    SqlKind_CREATE_SEQUENCE,
    SqlKind_ALTER_SEQUENCE,
    SqlKind_DROP_SEQUENCE,
    SqlKind_CREATE_INDEX,
    SqlKind_ALTER_INDEX,
    SqlKind_DROP_INDEX,
    SqlKind_CREATE_TYPE,
    SqlKind_DROP_TYPE,
    SqlKind_OTHER_DDL
  };
  return values;
}

inline const char * const *EnumNamesSqlKind() {
  static const char * const names[] = {
    "OTHER",
    "SELECT",
    "JOIN",
    "IDENTIFIER",
    "LITERAL",
    "OTHER_FUNCTION",
    "EXPLAIN",
    "DESCRIBE_SCHEMA",
    "DESCRIBE_TABLE",
    "INSERT",
    "DELETE",
    "UPDATE",
    "SET_OPTION",
    "DYNAMIC_PARAM",
    "ORDER_BY",
    "WITH",
    "WITH_ITEM",
    "UNION",
    "EXCEPT",
    "INTERSECT",
    "AS",
    "ARGUMENT_ASSIGNMENT",
    "DEFAULT",
    "OVER",
    "FILTER",
    "WINDOW",
    "MERGE",
    "TABLESAMPLE",
    "MATCH_RECOGNIZE",
    "TIMES",
    "DIVIDE",
    "MOD",
    "PLUS",
    "MINUS",
    "PATTERN_ALTER",
    "PATTERN_CONCAT",
    "IN",
    "NOT_IN",
    "LESS_THAN",
    "GREATER_THAN",
    "LESS_THAN_OR_EQUAL",
    "GREATER_THAN_OR_EQUAL",
    "EQUALS",
    "NOT_EQUALS",
    "IS_DISTINCT_FROM",
    "IS_NOT_DISTINCT_FROM",
    "OR",
    "AND",
    "DOT",
    "OVERLAPS",
    "CONTAINS",
    "PRECEDES",
    "IMMEDIATELY_PRECEDES",
    "SUCCEEDS",
    "IMMEDIATELY_SUCCEEDS",
    "PERIOD_EQUALS",
    "LIKE",
    "SIMILAR",
    "BETWEEN",
    "CASE",
    "NULLIF",
    "COALESCE",
    "DECODE",
    "NVL",
    "GREATEST",
    "LEAST",
    "TIMESTAMP_ADD",
    "TIMESTAMP_DIFF",
    "NOT",
    "PLUS_PREFIX",
    "MINUS_PREFIX",
    "EXISTS",
    "SOME",
    "ALL",
    "VALUES",
    "EXPLICIT_TABLE",
    "SCALAR_QUERY",
    "PROCEDURE_CALL",
    "NEW_SPECIFICATION",
    "FINAL",
    "RUNNING",
    "PREV",
    "NEXT",
    "FIRST",
    "LAST",
    "CLASSIFIER",
    "MATCH_NUMBER",
    "SKIP_TO_FIRST",
    "SKIP_TO_LAST",
    "DESCENDING",
    "NULLS_FIRST",
    "NULLS_LAST",
    "IS_TRUE",
    "IS_FALSE",
    "IS_NOT_TRUE",
    "IS_NOT_FALSE",
    "IS_UNKNOWN",
    "IS_NULL",
    "IS_NOT_NULL",
    "PRECEDING",
    "FOLLOWING",
    "FIELD_ACCESS",
    "INPUT_REF",
    "TABLE_INPUT_REF",
    "PATTERN_INPUT_REF",
    "LOCAL_REF",
    "CORREL_VARIABLE",
    "PATTERN_QUANTIFIER",
    "ROW",
    "COLUMN_LIST",
    "CAST",
    "NEXT_VALUE",
    "CURRENT_VALUE",
    "FLOOR",
    "CEIL",
    "TRIM",
    "LTRIM",
    "RTRIM",
    "EXTRACT",
    "JDBC_FN",
    "MULTISET_VALUE_CONSTRUCTOR",
    "MULTISET_QUERY_CONSTRUCTOR",
    "UNNEST",
    "LATERAL",
    "COLLECTION_TABLE",
    "ARRAY_VALUE_CONSTRUCTOR",
    "ARRAY_QUERY_CONSTRUCTOR",
    "MAP_VALUE_CONSTRUCTOR",
    "MAP_QUERY_CONSTRUCTOR",
    "CURSOR",
    "LITERAL_CHAIN",
    "ESCAPE",
    "REINTERPRET",
    "EXTEND",
    "CUBE",
    "ROLLUP",
    "GROUPING_SETS",
    "GROUPING",
    "GROUPING_ID",
    "GROUP_ID",
    "PATTERN_PERMUTE",
    "PATTERN_EXCLUDED",
    "COUNT",
    "SUM",
    "SUM0",
    "MIN",
    "MAX",
    "LEAD",
    "LAG",
    "FIRST_VALUE",
    "LAST_VALUE",
    "ANY_VALUE",
    "COVAR_POP",
    "COVAR_SAMP",
    "REGR_COUNT",
    "REGR_SXX",
    "REGR_SYY",
    "AVG",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "VAR_POP",
    "VAR_SAMP",
    "NTILE",
    "NTH_VALUE",
    "COLLECT",
    "FUSION",
    "SINGLE_VALUE",
    "ROW_NUMBER",
    "RANK",
    "PERCENT_RANK",
    "DENSE_RANK",
    "CUME_DIST",
    "TUMBLE",
    "TUMBLE_START",
    "TUMBLE_END",
    "HOP",
    "HOP_START",
    "HOP_END",
    "SESSION",
    "SESSION_START",
    "SESSION_END",
    "COLUMN_DECL",
    "ATTRIBUTE_DEF",
    "CHECK",
    "UNIQUE",
    "PRIMARY_KEY",
    "FOREIGN_KEY",
    "COMMIT",
    "ROLLBACK",
    "ALTER_SESSION",
    "CREATE_SCHEMA",
    "CREATE_FOREIGN_SCHEMA",
    "DROP_SCHEMA",
    "CREATE_TABLE",
    "ALTER_TABLE",
    "DROP_TABLE",
    "CREATE_VIEW",
    "ALTER_VIEW",
    "DROP_VIEW",
    "CREATE_MATERIALIZED_VIEW",
    "ALTER_MATERIALIZED_VIEW",
    "DROP_MATERIALIZED_VIEW",
    "CREATE_SEQUENCE",
    "ALTER_SEQUENCE",
    "DROP_SEQUENCE",
    "CREATE_INDEX",
    "ALTER_INDEX",
    "DROP_INDEX",
    "CREATE_TYPE",
    "DROP_TYPE",
    "OTHER_DDL",
    nullptr
  };
  return names;
}

inline const char *EnumNameSqlKind(SqlKind e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSqlKind()[index];
}

enum SqlTypeName {
  SqlTypeName_ANY = 0,
  SqlTypeName_ARRAY = 1,
  SqlTypeName_BIGINT = 2,
  SqlTypeName_BINARY = 3,
  SqlTypeName_BOOLEAN = 4,
  SqlTypeName_CHAR = 5,
  SqlTypeName_COLUMN_LIST = 6,
  SqlTypeName_CURSOR = 7,
  SqlTypeName_DATE = 8,
  SqlTypeName_DECIMAL = 9,
  SqlTypeName_DISTINCT = 10,
  SqlTypeName_DOUBLE = 11,
  SqlTypeName_DYNAMIC_STAR = 12,
  SqlTypeName_FLOAT = 13,
  SqlTypeName_GEOMETRY = 14,
  SqlTypeName_INTEGER = 15,
  SqlTypeName_INTERVAL_DAY = 16,
  SqlTypeName_INTERVAL_DAY_HOUR = 17,
  SqlTypeName_INTERVAL_DAY_MINUTE = 18,
  SqlTypeName_INTERVAL_DAY_SECOND = 19,
  SqlTypeName_INTERVAL_HOUR = 20,
  SqlTypeName_INTERVAL_HOUR_MINUTE = 21,
  SqlTypeName_INTERVAL_HOUR_SECOND = 22,
  SqlTypeName_INTERVAL_MINUTE = 23,
  SqlTypeName_INTERVAL_MINUTE_SECOND = 24,
  SqlTypeName_INTERVAL_MONTH = 25,
  SqlTypeName_INTERVAL_SECOND = 26,
  SqlTypeName_INTERVAL_YEAR = 27,
  SqlTypeName_INTERVAL_YEAR_MONTH = 28,
  SqlTypeName_MAP = 29,
  SqlTypeName_MULTISET = 30,
  SqlTypeName_NULL = 31,
  SqlTypeName_OTHER = 32,
  SqlTypeName_REAL = 33,
  SqlTypeName_ROW = 34,
  SqlTypeName_SMALLINT = 35,
  SqlTypeName_STRUCTURED = 36,
  SqlTypeName_SYMBOL = 37,
  SqlTypeName_TIME = 38,
  SqlTypeName_TIME_WITH_LOCAL_TIME_ZONE = 39,
  SqlTypeName_TIMESTAMP = 40,
  SqlTypeName_TIMESTAMP_WITH_LOCAL_TIME_ZONE = 41,
  SqlTypeName_TINYINT = 42,
  SqlTypeName_VARBINARY = 43,
  SqlTypeName_VARCHAR = 44,
  SqlTypeName_MIN = SqlTypeName_ANY,
  SqlTypeName_MAX = SqlTypeName_VARCHAR
};

inline const SqlTypeName (&EnumValuesSqlTypeName())[45] {
  static const SqlTypeName values[] = {
    SqlTypeName_ANY,
    SqlTypeName_ARRAY,
    SqlTypeName_BIGINT,
    SqlTypeName_BINARY,
    SqlTypeName_BOOLEAN,
    SqlTypeName_CHAR,
    SqlTypeName_COLUMN_LIST,
    SqlTypeName_CURSOR,
    SqlTypeName_DATE,
    SqlTypeName_DECIMAL,
    SqlTypeName_DISTINCT,
    SqlTypeName_DOUBLE,
    SqlTypeName_DYNAMIC_STAR,
    SqlTypeName_FLOAT,
    SqlTypeName_GEOMETRY,
    SqlTypeName_INTEGER,
    SqlTypeName_INTERVAL_DAY,
    SqlTypeName_INTERVAL_DAY_HOUR,
    SqlTypeName_INTERVAL_DAY_MINUTE,
    SqlTypeName_INTERVAL_DAY_SECOND,
    SqlTypeName_INTERVAL_HOUR,
    SqlTypeName_INTERVAL_HOUR_MINUTE,
    SqlTypeName_INTERVAL_HOUR_SECOND,
    SqlTypeName_INTERVAL_MINUTE,
    SqlTypeName_INTERVAL_MINUTE_SECOND,
    SqlTypeName_INTERVAL_MONTH,
    SqlTypeName_INTERVAL_SECOND,
    SqlTypeName_INTERVAL_YEAR,
    SqlTypeName_INTERVAL_YEAR_MONTH,
    SqlTypeName_MAP,
    SqlTypeName_MULTISET,
    SqlTypeName_NULL,
    SqlTypeName_OTHER,
    SqlTypeName_REAL,
    SqlTypeName_ROW,
    SqlTypeName_SMALLINT,
    SqlTypeName_STRUCTURED,
    SqlTypeName_SYMBOL,
    SqlTypeName_TIME,
    SqlTypeName_TIME_WITH_LOCAL_TIME_ZONE,
    SqlTypeName_TIMESTAMP,
    SqlTypeName_TIMESTAMP_WITH_LOCAL_TIME_ZONE,
    SqlTypeName_TINYINT,
    SqlTypeName_VARBINARY,
    SqlTypeName_VARCHAR
  };
  return values;
}

inline const char * const *EnumNamesSqlTypeName() {
  static const char * const names[] = {
    "ANY",
    "ARRAY",
    "BIGINT",
    "BINARY",
    "BOOLEAN",
    "CHAR",
    "COLUMN_LIST",
    "CURSOR",
    "DATE",
    "DECIMAL",
    "DISTINCT",
    "DOUBLE",
    "DYNAMIC_STAR",
    "FLOAT",
    "GEOMETRY",
    "INTEGER",
    "INTERVAL_DAY",
    "INTERVAL_DAY_HOUR",
    "INTERVAL_DAY_MINUTE",
    "INTERVAL_DAY_SECOND",
    "INTERVAL_HOUR",
    "INTERVAL_HOUR_MINUTE",
    "INTERVAL_HOUR_SECOND",
    "INTERVAL_MINUTE",
    "INTERVAL_MINUTE_SECOND",
    "INTERVAL_MONTH",
    "INTERVAL_SECOND",
    "INTERVAL_YEAR",
    "INTERVAL_YEAR_MONTH",
    "MAP",
    "MULTISET",
    "NULL",
    "OTHER",
    "REAL",
    "ROW",
    "SMALLINT",
    "STRUCTURED",
    "SYMBOL",
    "TIME",
    "TIME_WITH_LOCAL_TIME_ZONE",
    "TIMESTAMP",
    "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
    "TINYINT",
    "VARBINARY",
    "VARCHAR",
    nullptr
  };
  return names;
}

inline const char *EnumNameSqlTypeName(SqlTypeName e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSqlTypeName()[index];
}

}  // namespace messages
}  // namespace plan
}  // namespace calcite
}  // namespace protocol
}  // namespace blazingdb
}  // namespace com

namespace blazingdb {
namespace protocol {

enum NodeConnectionType {
  NodeConnectionType_TPC = 0,
  NodeConnectionType_IPC = 1,
  NodeConnectionType_MIN = NodeConnectionType_TPC,
  NodeConnectionType_MAX = NodeConnectionType_IPC
};

inline const NodeConnectionType (&EnumValuesNodeConnectionType())[2] {
  static const NodeConnectionType values[] = {
    NodeConnectionType_TPC,
    NodeConnectionType_IPC
  };
  return values;
}

inline const char * const *EnumNamesNodeConnectionType() {
  static const char * const names[] = {
    "TPC",
    "IPC",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeConnectionType(NodeConnectionType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesNodeConnectionType()[index];
}

enum Status {
  Status_Error = 0,
  Status_Success = 1,
  Status_MIN = Status_Error,
  Status_MAX = Status_Success
};

inline const Status (&EnumValuesStatus())[2] {
  static const Status values[] = {
    Status_Error,
    Status_Success
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[] = {
    "Error",
    "Success",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesStatus()[index];
}

MANUALLY_ALIGNED_STRUCT(8) Header FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t messageType_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;
  uint64_t accessToken_;

 public:
  Header() {
    memset(this, 0, sizeof(Header));
  }
  Header(int8_t _messageType, uint64_t _accessToken)
      : messageType_(flatbuffers::EndianScalar(_messageType)),
        padding0__(0),
        padding1__(0),
        padding2__(0),
        accessToken_(flatbuffers::EndianScalar(_accessToken)) {
    (void)padding0__;    (void)padding1__;    (void)padding2__;
  }
  int8_t messageType() const {
    return flatbuffers::EndianScalar(messageType_);
  }
  uint64_t accessToken() const {
    return flatbuffers::EndianScalar(accessToken_);
  }
};
STRUCT_END(Header, 16);

namespace calcite {

struct DMLRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUERY = 4
  };
  const flatbuffers::String *query() const {
    return GetPointer<const flatbuffers::String *>(VT_QUERY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.Verify(query()) &&
           verifier.EndTable();
  }
};

struct DMLRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_query(flatbuffers::Offset<flatbuffers::String> query) {
    fbb_.AddOffset(DMLRequest::VT_QUERY, query);
  }
  explicit DMLRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DMLRequestBuilder &operator=(const DMLRequestBuilder &);
  flatbuffers::Offset<DMLRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DMLRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DMLRequest> CreateDMLRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> query = 0) {
  DMLRequestBuilder builder_(_fbb);
  builder_.add_query(query);
  return builder_.Finish();
}

inline flatbuffers::Offset<DMLRequest> CreateDMLRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *query = nullptr) {
  return blazingdb::protocol::calcite::CreateDMLRequest(
      _fbb,
      query ? _fbb.CreateString(query) : 0);
}

struct DDLRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUERY = 4
  };
  const flatbuffers::String *query() const {
    return GetPointer<const flatbuffers::String *>(VT_QUERY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.Verify(query()) &&
           verifier.EndTable();
  }
};

struct DDLRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_query(flatbuffers::Offset<flatbuffers::String> query) {
    fbb_.AddOffset(DDLRequest::VT_QUERY, query);
  }
  explicit DDLRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLRequestBuilder &operator=(const DDLRequestBuilder &);
  flatbuffers::Offset<DDLRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLRequest> CreateDDLRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> query = 0) {
  DDLRequestBuilder builder_(_fbb);
  builder_.add_query(query);
  return builder_.Finish();
}

inline flatbuffers::Offset<DDLRequest> CreateDDLRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *query = nullptr) {
  return blazingdb::protocol::calcite::CreateDDLRequest(
      _fbb,
      query ? _fbb.CreateString(query) : 0);
}

struct DDLCreateTableRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_COLUMNNAMES = 6,
    VT_COLUMNTYPES = 8,
    VT_DBNAME = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNNAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnTypes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNTYPES);
  }
  const flatbuffers::String *dbName() const {
    return GetPointer<const flatbuffers::String *>(VT_DBNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_COLUMNNAMES) &&
           verifier.Verify(columnNames()) &&
           verifier.VerifyVectorOfStrings(columnNames()) &&
           VerifyOffset(verifier, VT_COLUMNTYPES) &&
           verifier.Verify(columnTypes()) &&
           verifier.VerifyVectorOfStrings(columnTypes()) &&
           VerifyOffset(verifier, VT_DBNAME) &&
           verifier.Verify(dbName()) &&
           verifier.EndTable();
  }
};

struct DDLCreateTableRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_NAME, name);
  }
  void add_columnNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_COLUMNNAMES, columnNames);
  }
  void add_columnTypes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnTypes) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_COLUMNTYPES, columnTypes);
  }
  void add_dbName(flatbuffers::Offset<flatbuffers::String> dbName) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_DBNAME, dbName);
  }
  explicit DDLCreateTableRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLCreateTableRequestBuilder &operator=(const DDLCreateTableRequestBuilder &);
  flatbuffers::Offset<DDLCreateTableRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLCreateTableRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLCreateTableRequest> CreateDDLCreateTableRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnTypes = 0,
    flatbuffers::Offset<flatbuffers::String> dbName = 0) {
  DDLCreateTableRequestBuilder builder_(_fbb);
  builder_.add_dbName(dbName);
  builder_.add_columnTypes(columnTypes);
  builder_.add_columnNames(columnNames);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<DDLCreateTableRequest> CreateDDLCreateTableRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnNames = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnTypes = nullptr,
    const char *dbName = nullptr) {
  return blazingdb::protocol::calcite::CreateDDLCreateTableRequest(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      columnNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnNames) : 0,
      columnTypes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnTypes) : 0,
      dbName ? _fbb.CreateString(dbName) : 0);
}

struct DDLDropTableRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_DBNAME = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *dbName() const {
    return GetPointer<const flatbuffers::String *>(VT_DBNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_DBNAME) &&
           verifier.Verify(dbName()) &&
           verifier.EndTable();
  }
};

struct DDLDropTableRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DDLDropTableRequest::VT_NAME, name);
  }
  void add_dbName(flatbuffers::Offset<flatbuffers::String> dbName) {
    fbb_.AddOffset(DDLDropTableRequest::VT_DBNAME, dbName);
  }
  explicit DDLDropTableRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLDropTableRequestBuilder &operator=(const DDLDropTableRequestBuilder &);
  flatbuffers::Offset<DDLDropTableRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLDropTableRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLDropTableRequest> CreateDDLDropTableRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> dbName = 0) {
  DDLDropTableRequestBuilder builder_(_fbb);
  builder_.add_dbName(dbName);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<DDLDropTableRequest> CreateDDLDropTableRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *dbName = nullptr) {
  return blazingdb::protocol::calcite::CreateDDLDropTableRequest(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      dbName ? _fbb.CreateString(dbName) : 0);
}

}  // namespace calcite

namespace orchestrator {

struct DDLCreateTableRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_COLUMNNAMES = 6,
    VT_COLUMNTYPES = 8,
    VT_DBNAME = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNNAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnTypes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNTYPES);
  }
  const flatbuffers::String *dbName() const {
    return GetPointer<const flatbuffers::String *>(VT_DBNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_COLUMNNAMES) &&
           verifier.Verify(columnNames()) &&
           verifier.VerifyVectorOfStrings(columnNames()) &&
           VerifyOffset(verifier, VT_COLUMNTYPES) &&
           verifier.Verify(columnTypes()) &&
           verifier.VerifyVectorOfStrings(columnTypes()) &&
           VerifyOffset(verifier, VT_DBNAME) &&
           verifier.Verify(dbName()) &&
           verifier.EndTable();
  }
};

struct DDLCreateTableRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_NAME, name);
  }
  void add_columnNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_COLUMNNAMES, columnNames);
  }
  void add_columnTypes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnTypes) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_COLUMNTYPES, columnTypes);
  }
  void add_dbName(flatbuffers::Offset<flatbuffers::String> dbName) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_DBNAME, dbName);
  }
  explicit DDLCreateTableRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLCreateTableRequestBuilder &operator=(const DDLCreateTableRequestBuilder &);
  flatbuffers::Offset<DDLCreateTableRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLCreateTableRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLCreateTableRequest> CreateDDLCreateTableRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnTypes = 0,
    flatbuffers::Offset<flatbuffers::String> dbName = 0) {
  DDLCreateTableRequestBuilder builder_(_fbb);
  builder_.add_dbName(dbName);
  builder_.add_columnTypes(columnTypes);
  builder_.add_columnNames(columnNames);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<DDLCreateTableRequest> CreateDDLCreateTableRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnNames = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnTypes = nullptr,
    const char *dbName = nullptr) {
  return blazingdb::protocol::orchestrator::CreateDDLCreateTableRequest(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      columnNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnNames) : 0,
      columnTypes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnTypes) : 0,
      dbName ? _fbb.CreateString(dbName) : 0);
}

struct DDLDropTableRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_DBNAME = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *dbName() const {
    return GetPointer<const flatbuffers::String *>(VT_DBNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_DBNAME) &&
           verifier.Verify(dbName()) &&
           verifier.EndTable();
  }
};

struct DDLDropTableRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DDLDropTableRequest::VT_NAME, name);
  }
  void add_dbName(flatbuffers::Offset<flatbuffers::String> dbName) {
    fbb_.AddOffset(DDLDropTableRequest::VT_DBNAME, dbName);
  }
  explicit DDLDropTableRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLDropTableRequestBuilder &operator=(const DDLDropTableRequestBuilder &);
  flatbuffers::Offset<DDLDropTableRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLDropTableRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLDropTableRequest> CreateDDLDropTableRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> dbName = 0) {
  DDLDropTableRequestBuilder builder_(_fbb);
  builder_.add_dbName(dbName);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<DDLDropTableRequest> CreateDDLDropTableRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *dbName = nullptr) {
  return blazingdb::protocol::orchestrator::CreateDDLDropTableRequest(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      dbName ? _fbb.CreateString(dbName) : 0);
}

struct AuthRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AuthRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AuthRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthRequestBuilder &operator=(const AuthRequestBuilder &);
  flatbuffers::Offset<AuthRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AuthRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuthRequest> CreateAuthRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AuthRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

}  // namespace orchestrator

namespace gdf {

struct gdf_dtype_extra_info FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIME_UNIT = 4
  };
  gdf_time_unit time_unit() const {
    return static_cast<gdf_time_unit>(GetField<int8_t>(VT_TIME_UNIT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TIME_UNIT) &&
           verifier.EndTable();
  }
};

struct gdf_dtype_extra_infoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_unit(gdf_time_unit time_unit) {
    fbb_.AddElement<int8_t>(gdf_dtype_extra_info::VT_TIME_UNIT, static_cast<int8_t>(time_unit), 0);
  }
  explicit gdf_dtype_extra_infoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gdf_dtype_extra_infoBuilder &operator=(const gdf_dtype_extra_infoBuilder &);
  flatbuffers::Offset<gdf_dtype_extra_info> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gdf_dtype_extra_info>(end);
    return o;
  }
};

inline flatbuffers::Offset<gdf_dtype_extra_info> Creategdf_dtype_extra_info(
    flatbuffers::FlatBufferBuilder &_fbb,
    gdf_time_unit time_unit = gdf_time_unit_TIME_UNIT_NONE) {
  gdf_dtype_extra_infoBuilder builder_(_fbb);
  builder_.add_time_unit(time_unit);
  return builder_.Finish();
}

struct cudaIpcMemHandle_t FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESERVED = 4
  };
  const flatbuffers::Vector<int8_t> *reserved() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_RESERVED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESERVED) &&
           verifier.Verify(reserved()) &&
           verifier.EndTable();
  }
};

struct cudaIpcMemHandle_tBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reserved(flatbuffers::Offset<flatbuffers::Vector<int8_t>> reserved) {
    fbb_.AddOffset(cudaIpcMemHandle_t::VT_RESERVED, reserved);
  }
  explicit cudaIpcMemHandle_tBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  cudaIpcMemHandle_tBuilder &operator=(const cudaIpcMemHandle_tBuilder &);
  flatbuffers::Offset<cudaIpcMemHandle_t> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<cudaIpcMemHandle_t>(end);
    return o;
  }
};

inline flatbuffers::Offset<cudaIpcMemHandle_t> CreatecudaIpcMemHandle_t(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> reserved = 0) {
  cudaIpcMemHandle_tBuilder builder_(_fbb);
  builder_.add_reserved(reserved);
  return builder_.Finish();
}

inline flatbuffers::Offset<cudaIpcMemHandle_t> CreatecudaIpcMemHandle_tDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *reserved = nullptr) {
  return blazingdb::protocol::gdf::CreatecudaIpcMemHandle_t(
      _fbb,
      reserved ? _fbb.CreateVector<int8_t>(*reserved) : 0);
}

struct gdf_column_handler FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4,
    VT_VALID = 6,
    VT_SIZE = 8,
    VT_DTYPE = 10,
    VT_DTYPE_INFO = 12,
    VT_NULL_COUNT = 14
  };
  const cudaIpcMemHandle_t *data() const {
    return GetPointer<const cudaIpcMemHandle_t *>(VT_DATA);
  }
  const cudaIpcMemHandle_t *valid() const {
    return GetPointer<const cudaIpcMemHandle_t *>(VT_VALID);
  }
  uint16_t size() const {
    return GetField<uint16_t>(VT_SIZE, 0);
  }
  gdf_dtype dtype() const {
    return static_cast<gdf_dtype>(GetField<int8_t>(VT_DTYPE, 0));
  }
  const gdf_dtype_extra_info *dtype_info() const {
    return GetPointer<const gdf_dtype_extra_info *>(VT_DTYPE_INFO);
  }
  uint16_t null_count() const {
    return GetField<uint16_t>(VT_NULL_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           VerifyOffset(verifier, VT_VALID) &&
           verifier.VerifyTable(valid()) &&
           VerifyField<uint16_t>(verifier, VT_SIZE) &&
           VerifyField<int8_t>(verifier, VT_DTYPE) &&
           VerifyOffset(verifier, VT_DTYPE_INFO) &&
           verifier.VerifyTable(dtype_info()) &&
           VerifyField<uint16_t>(verifier, VT_NULL_COUNT) &&
           verifier.EndTable();
  }
};

struct gdf_column_handlerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<cudaIpcMemHandle_t> data) {
    fbb_.AddOffset(gdf_column_handler::VT_DATA, data);
  }
  void add_valid(flatbuffers::Offset<cudaIpcMemHandle_t> valid) {
    fbb_.AddOffset(gdf_column_handler::VT_VALID, valid);
  }
  void add_size(uint16_t size) {
    fbb_.AddElement<uint16_t>(gdf_column_handler::VT_SIZE, size, 0);
  }
  void add_dtype(gdf_dtype dtype) {
    fbb_.AddElement<int8_t>(gdf_column_handler::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  void add_dtype_info(flatbuffers::Offset<gdf_dtype_extra_info> dtype_info) {
    fbb_.AddOffset(gdf_column_handler::VT_DTYPE_INFO, dtype_info);
  }
  void add_null_count(uint16_t null_count) {
    fbb_.AddElement<uint16_t>(gdf_column_handler::VT_NULL_COUNT, null_count, 0);
  }
  explicit gdf_column_handlerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gdf_column_handlerBuilder &operator=(const gdf_column_handlerBuilder &);
  flatbuffers::Offset<gdf_column_handler> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gdf_column_handler>(end);
    return o;
  }
};

inline flatbuffers::Offset<gdf_column_handler> Creategdf_column_handler(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<cudaIpcMemHandle_t> data = 0,
    flatbuffers::Offset<cudaIpcMemHandle_t> valid = 0,
    uint16_t size = 0,
    gdf_dtype dtype = gdf_dtype_GDF_invalid,
    flatbuffers::Offset<gdf_dtype_extra_info> dtype_info = 0,
    uint16_t null_count = 0) {
  gdf_column_handlerBuilder builder_(_fbb);
  builder_.add_dtype_info(dtype_info);
  builder_.add_valid(valid);
  builder_.add_data(data);
  builder_.add_null_count(null_count);
  builder_.add_size(size);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

}  // namespace gdf

struct BlazingTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_COLUMNS = 6,
    VT_COLUMNNAMES = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>> *columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>> *>(VT_COLUMNS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNNAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.Verify(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           VerifyOffset(verifier, VT_COLUMNNAMES) &&
           verifier.Verify(columnNames()) &&
           verifier.VerifyVectorOfStrings(columnNames()) &&
           verifier.EndTable();
  }
};

struct BlazingTableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(BlazingTable::VT_NAME, name);
  }
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>>> columns) {
    fbb_.AddOffset(BlazingTable::VT_COLUMNS, columns);
  }
  void add_columnNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames) {
    fbb_.AddOffset(BlazingTable::VT_COLUMNNAMES, columnNames);
  }
  explicit BlazingTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlazingTableBuilder &operator=(const BlazingTableBuilder &);
  flatbuffers::Offset<BlazingTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlazingTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlazingTable> CreateBlazingTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>>> columns = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames = 0) {
  BlazingTableBuilder builder_(_fbb);
  builder_.add_columnNames(columnNames);
  builder_.add_columns(columns);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlazingTable> CreateBlazingTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>> *columns = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnNames = nullptr) {
  return blazingdb::protocol::CreateBlazingTable(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      columns ? _fbb.CreateVector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>>(*columns) : 0,
      columnNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnNames) : 0);
}

struct TableGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TABLES = 4,
    VT_NAME = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<BlazingTable>> *tables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BlazingTable>> *>(VT_TABLES);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TABLES) &&
           verifier.Verify(tables()) &&
           verifier.VerifyVectorOfTables(tables()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct TableGroupBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BlazingTable>>> tables) {
    fbb_.AddOffset(TableGroup::VT_TABLES, tables);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TableGroup::VT_NAME, name);
  }
  explicit TableGroupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableGroupBuilder &operator=(const TableGroupBuilder &);
  flatbuffers::Offset<TableGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableGroup>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableGroup> CreateTableGroup(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BlazingTable>>> tables = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  TableGroupBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_tables(tables);
  return builder_.Finish();
}

inline flatbuffers::Offset<TableGroup> CreateTableGroupDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BlazingTable>> *tables = nullptr,
    const char *name = nullptr) {
  return blazingdb::protocol::CreateTableGroup(
      _fbb,
      tables ? _fbb.CreateVector<flatbuffers::Offset<BlazingTable>>(*tables) : 0,
      name ? _fbb.CreateString(name) : 0);
}

namespace orchestrator {

struct DMLRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUERY = 4,
    VT_TABLEGROUP = 6
  };
  const flatbuffers::String *query() const {
    return GetPointer<const flatbuffers::String *>(VT_QUERY);
  }
  const blazingdb::protocol::TableGroup *tableGroup() const {
    return GetPointer<const blazingdb::protocol::TableGroup *>(VT_TABLEGROUP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.Verify(query()) &&
           VerifyOffset(verifier, VT_TABLEGROUP) &&
           verifier.VerifyTable(tableGroup()) &&
           verifier.EndTable();
  }
};

struct DMLRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_query(flatbuffers::Offset<flatbuffers::String> query) {
    fbb_.AddOffset(DMLRequest::VT_QUERY, query);
  }
  void add_tableGroup(flatbuffers::Offset<blazingdb::protocol::TableGroup> tableGroup) {
    fbb_.AddOffset(DMLRequest::VT_TABLEGROUP, tableGroup);
  }
  explicit DMLRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DMLRequestBuilder &operator=(const DMLRequestBuilder &);
  flatbuffers::Offset<DMLRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DMLRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DMLRequest> CreateDMLRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> query = 0,
    flatbuffers::Offset<blazingdb::protocol::TableGroup> tableGroup = 0) {
  DMLRequestBuilder builder_(_fbb);
  builder_.add_tableGroup(tableGroup);
  builder_.add_query(query);
  return builder_.Finish();
}

inline flatbuffers::Offset<DMLRequest> CreateDMLRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *query = nullptr,
    flatbuffers::Offset<blazingdb::protocol::TableGroup> tableGroup = 0) {
  return blazingdb::protocol::orchestrator::CreateDMLRequest(
      _fbb,
      query ? _fbb.CreateString(query) : 0,
      tableGroup);
}

struct DDLRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUERY = 4
  };
  const flatbuffers::String *query() const {
    return GetPointer<const flatbuffers::String *>(VT_QUERY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.Verify(query()) &&
           verifier.EndTable();
  }
};

struct DDLRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_query(flatbuffers::Offset<flatbuffers::String> query) {
    fbb_.AddOffset(DDLRequest::VT_QUERY, query);
  }
  explicit DDLRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLRequestBuilder &operator=(const DDLRequestBuilder &);
  flatbuffers::Offset<DDLRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLRequest> CreateDDLRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> query = 0) {
  DDLRequestBuilder builder_(_fbb);
  builder_.add_query(query);
  return builder_.Finish();
}

inline flatbuffers::Offset<DDLRequest> CreateDDLRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *query = nullptr) {
  return blazingdb::protocol::orchestrator::CreateDDLRequest(
      _fbb,
      query ? _fbb.CreateString(query) : 0);
}

}  // namespace orchestrator

namespace interpreter {

struct DMLRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOGICALPLAN = 4,
    VT_TABLEGROUP = 6
  };
  const flatbuffers::String *logicalPlan() const {
    return GetPointer<const flatbuffers::String *>(VT_LOGICALPLAN);
  }
  const blazingdb::protocol::TableGroup *tableGroup() const {
    return GetPointer<const blazingdb::protocol::TableGroup *>(VT_TABLEGROUP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOGICALPLAN) &&
           verifier.Verify(logicalPlan()) &&
           VerifyOffset(verifier, VT_TABLEGROUP) &&
           verifier.VerifyTable(tableGroup()) &&
           verifier.EndTable();
  }
};

struct DMLRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_logicalPlan(flatbuffers::Offset<flatbuffers::String> logicalPlan) {
    fbb_.AddOffset(DMLRequest::VT_LOGICALPLAN, logicalPlan);
  }
  void add_tableGroup(flatbuffers::Offset<blazingdb::protocol::TableGroup> tableGroup) {
    fbb_.AddOffset(DMLRequest::VT_TABLEGROUP, tableGroup);
  }
  explicit DMLRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DMLRequestBuilder &operator=(const DMLRequestBuilder &);
  flatbuffers::Offset<DMLRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DMLRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DMLRequest> CreateDMLRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> logicalPlan = 0,
    flatbuffers::Offset<blazingdb::protocol::TableGroup> tableGroup = 0) {
  DMLRequestBuilder builder_(_fbb);
  builder_.add_tableGroup(tableGroup);
  builder_.add_logicalPlan(logicalPlan);
  return builder_.Finish();
}

inline flatbuffers::Offset<DMLRequest> CreateDMLRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *logicalPlan = nullptr,
    flatbuffers::Offset<blazingdb::protocol::TableGroup> tableGroup = 0) {
  return blazingdb::protocol::interpreter::CreateDMLRequest(
      _fbb,
      logicalPlan ? _fbb.CreateString(logicalPlan) : 0,
      tableGroup);
}

struct GetResultRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULTTOKEN = 4
  };
  uint64_t resultToken() const {
    return GetField<uint64_t>(VT_RESULTTOKEN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RESULTTOKEN) &&
           verifier.EndTable();
  }
};

struct GetResultRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_resultToken(uint64_t resultToken) {
    fbb_.AddElement<uint64_t>(GetResultRequest::VT_RESULTTOKEN, resultToken, 0);
  }
  explicit GetResultRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetResultRequestBuilder &operator=(const GetResultRequestBuilder &);
  flatbuffers::Offset<GetResultRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetResultRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetResultRequest> CreateGetResultRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t resultToken = 0) {
  GetResultRequestBuilder builder_(_fbb);
  builder_.add_resultToken(resultToken);
  return builder_.Finish();
}

}  // namespace interpreter

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_PAYLOAD = 6
  };
  const Header *header() const {
    return GetStruct<const Header *>(VT_HEADER);
  }
  const flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Header>(verifier, VT_HEADER) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.Verify(payload()) &&
           verifier.EndTable();
  }
};

struct RequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(const Header *header) {
    fbb_.AddStruct(Request::VT_HEADER, header);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(Request::VT_PAYLOAD, payload);
  }
  explicit RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Header *header = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_header(header);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request> CreateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Header *header = 0,
    const std::vector<uint8_t> *payload = nullptr) {
  return blazingdb::protocol::CreateRequest(
      _fbb,
      header,
      payload ? _fbb.CreateVector<uint8_t>(*payload) : 0);
}

}  // namespace protocol
}  // namespace blazingdb

namespace com {
namespace blazingdb {
namespace protocol {
namespace calcite {
namespace plan {
namespace messages {

struct TableScan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUALIFIEDNAME = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *qualifiedName() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_QUALIFIEDNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUALIFIEDNAME) &&
           verifier.Verify(qualifiedName()) &&
           verifier.VerifyVectorOfStrings(qualifiedName()) &&
           verifier.EndTable();
  }
};

struct TableScanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_qualifiedName(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> qualifiedName) {
    fbb_.AddOffset(TableScan::VT_QUALIFIEDNAME, qualifiedName);
  }
  explicit TableScanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableScanBuilder &operator=(const TableScanBuilder &);
  flatbuffers::Offset<TableScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableScan>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableScan> CreateTableScan(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> qualifiedName = 0) {
  TableScanBuilder builder_(_fbb);
  builder_.add_qualifiedName(qualifiedName);
  return builder_.Finish();
}

inline flatbuffers::Offset<TableScan> CreateTableScanDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *qualifiedName = nullptr) {
  return com::blazingdb::protocol::calcite::plan::messages::CreateTableScan(
      _fbb,
      qualifiedName ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*qualifiedName) : 0);
}

struct LogicalProject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLUMNNAMES = 4,
    VT_COLUMNVALUES = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNNAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnValues() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNVALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLUMNNAMES) &&
           verifier.Verify(columnNames()) &&
           verifier.VerifyVectorOfStrings(columnNames()) &&
           VerifyOffset(verifier, VT_COLUMNVALUES) &&
           verifier.Verify(columnValues()) &&
           verifier.VerifyVectorOfStrings(columnValues()) &&
           verifier.EndTable();
  }
};

struct LogicalProjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_columnNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames) {
    fbb_.AddOffset(LogicalProject::VT_COLUMNNAMES, columnNames);
  }
  void add_columnValues(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnValues) {
    fbb_.AddOffset(LogicalProject::VT_COLUMNVALUES, columnValues);
  }
  explicit LogicalProjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalProjectBuilder &operator=(const LogicalProjectBuilder &);
  flatbuffers::Offset<LogicalProject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalProject>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalProject> CreateLogicalProject(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnValues = 0) {
  LogicalProjectBuilder builder_(_fbb);
  builder_.add_columnValues(columnValues);
  builder_.add_columnNames(columnNames);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogicalProject> CreateLogicalProjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnNames = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnValues = nullptr) {
  return com::blazingdb::protocol::calcite::plan::messages::CreateLogicalProject(
      _fbb,
      columnNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnNames) : 0,
      columnValues ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnValues) : 0);
}

struct LogicalAggregate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GROUPS = 4
  };
  const flatbuffers::Vector<uint64_t> *groups() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_GROUPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GROUPS) &&
           verifier.Verify(groups()) &&
           verifier.EndTable();
  }
};

struct LogicalAggregateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_groups(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> groups) {
    fbb_.AddOffset(LogicalAggregate::VT_GROUPS, groups);
  }
  explicit LogicalAggregateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalAggregateBuilder &operator=(const LogicalAggregateBuilder &);
  flatbuffers::Offset<LogicalAggregate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalAggregate>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalAggregate> CreateLogicalAggregate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> groups = 0) {
  LogicalAggregateBuilder builder_(_fbb);
  builder_.add_groups(groups);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogicalAggregate> CreateLogicalAggregateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *groups = nullptr) {
  return com::blazingdb::protocol::calcite::plan::messages::CreateLogicalAggregate(
      _fbb,
      groups ? _fbb.CreateVector<uint64_t>(*groups) : 0);
}

struct LogicalUnion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ALL = 4
  };
  bool all() const {
    return GetField<uint8_t>(VT_ALL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALL) &&
           verifier.EndTable();
  }
};

struct LogicalUnionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_all(bool all) {
    fbb_.AddElement<uint8_t>(LogicalUnion::VT_ALL, static_cast<uint8_t>(all), 0);
  }
  explicit LogicalUnionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalUnionBuilder &operator=(const LogicalUnionBuilder &);
  flatbuffers::Offset<LogicalUnion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalUnion>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalUnion> CreateLogicalUnion(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool all = false) {
  LogicalUnionBuilder builder_(_fbb);
  builder_.add_all(all);
  return builder_.Finish();
}

struct RelNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_DATA = 6,
    VT_INPUTS = 8
  };
  RelNodeType type() const {
    return static_cast<RelNodeType>(GetField<int16_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RelNode>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RelNode>> *>(VT_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.Verify(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           verifier.EndTable();
  }
};

struct RelNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(RelNodeType type) {
    fbb_.AddElement<int16_t>(RelNode::VT_TYPE, static_cast<int16_t>(type), 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(RelNode::VT_DATA, data);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RelNode>>> inputs) {
    fbb_.AddOffset(RelNode::VT_INPUTS, inputs);
  }
  explicit RelNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelNodeBuilder &operator=(const RelNodeBuilder &);
  flatbuffers::Offset<RelNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RelNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<RelNode> CreateRelNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    RelNodeType type = RelNodeType_Root,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RelNode>>> inputs = 0) {
  RelNodeBuilder builder_(_fbb);
  builder_.add_inputs(inputs);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RelNode> CreateRelNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    RelNodeType type = RelNodeType_Root,
    const std::vector<int8_t> *data = nullptr,
    const std::vector<flatbuffers::Offset<RelNode>> *inputs = nullptr) {
  return com::blazingdb::protocol::calcite::plan::messages::CreateRelNode(
      _fbb,
      type,
      data ? _fbb.CreateVector<int8_t>(*data) : 0,
      inputs ? _fbb.CreateVector<flatbuffers::Offset<RelNode>>(*inputs) : 0);
}

struct RexCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OPERANDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<RexNode>> *operands() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RexNode>> *>(VT_OPERANDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OPERANDS) &&
           verifier.Verify(operands()) &&
           verifier.VerifyVectorOfTables(operands()) &&
           verifier.EndTable();
  }
};

struct RexCallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_operands(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RexNode>>> operands) {
    fbb_.AddOffset(RexCall::VT_OPERANDS, operands);
  }
  explicit RexCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexCallBuilder &operator=(const RexCallBuilder &);
  flatbuffers::Offset<RexCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexCall> CreateRexCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RexNode>>> operands = 0) {
  RexCallBuilder builder_(_fbb);
  builder_.add_operands(operands);
  return builder_.Finish();
}

inline flatbuffers::Offset<RexCall> CreateRexCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<RexNode>> *operands = nullptr) {
  return com::blazingdb::protocol::calcite::plan::messages::CreateRexCall(
      _fbb,
      operands ? _fbb.CreateVector<flatbuffers::Offset<RexNode>>(*operands) : 0);
}

struct RexInputRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INDEX = 4
  };
  const flatbuffers::Vector<int32_t> *index() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INDEX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.Verify(index()) &&
           verifier.EndTable();
  }
};

struct RexInputRefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(flatbuffers::Offset<flatbuffers::Vector<int32_t>> index) {
    fbb_.AddOffset(RexInputRef::VT_INDEX, index);
  }
  explicit RexInputRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexInputRefBuilder &operator=(const RexInputRefBuilder &);
  flatbuffers::Offset<RexInputRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexInputRef>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexInputRef> CreateRexInputRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> index = 0) {
  RexInputRefBuilder builder_(_fbb);
  builder_.add_index(index);
  return builder_.Finish();
}

inline flatbuffers::Offset<RexInputRef> CreateRexInputRefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *index = nullptr) {
  return com::blazingdb::protocol::calcite::plan::messages::CreateRexInputRef(
      _fbb,
      index ? _fbb.CreateVector<int32_t>(*index) : 0);
}

struct RexLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct RexLiteralBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(RexLiteral::VT_VALUE, value);
  }
  explicit RexLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexLiteralBuilder &operator=(const RexLiteralBuilder &);
  flatbuffers::Offset<RexLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexLiteral> CreateRexLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0) {
  RexLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<RexLiteral> CreateRexLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *value = nullptr) {
  return com::blazingdb::protocol::calcite::plan::messages::CreateRexLiteral(
      _fbb,
      value ? _fbb.CreateVector<int8_t>(*value) : 0);
}

struct RexNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_SQLKIND = 6,
    VT_SQLTYPENAME = 8,
    VT_DATA = 10
  };
  RexNodeType type() const {
    return static_cast<RexNodeType>(GetField<int16_t>(VT_TYPE, 0));
  }
  SqlKind sqlKind() const {
    return static_cast<SqlKind>(GetField<int16_t>(VT_SQLKIND, 0));
  }
  SqlTypeName sqlTypeName() const {
    return static_cast<SqlTypeName>(GetField<int16_t>(VT_SQLTYPENAME, 0));
  }
  const flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_SQLKIND) &&
           VerifyField<int16_t>(verifier, VT_SQLTYPENAME) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct RexNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(RexNodeType type) {
    fbb_.AddElement<int16_t>(RexNode::VT_TYPE, static_cast<int16_t>(type), 0);
  }
  void add_sqlKind(SqlKind sqlKind) {
    fbb_.AddElement<int16_t>(RexNode::VT_SQLKIND, static_cast<int16_t>(sqlKind), 0);
  }
  void add_sqlTypeName(SqlTypeName sqlTypeName) {
    fbb_.AddElement<int16_t>(RexNode::VT_SQLTYPENAME, static_cast<int16_t>(sqlTypeName), 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(RexNode::VT_DATA, data);
  }
  explicit RexNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RexNodeBuilder &operator=(const RexNodeBuilder &);
  flatbuffers::Offset<RexNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RexNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<RexNode> CreateRexNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    RexNodeType type = RexNodeType_Root,
    SqlKind sqlKind = SqlKind_OTHER,
    SqlTypeName sqlTypeName = SqlTypeName_ANY,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0) {
  RexNodeBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_sqlTypeName(sqlTypeName);
  builder_.add_sqlKind(sqlKind);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RexNode> CreateRexNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    RexNodeType type = RexNodeType_Root,
    SqlKind sqlKind = SqlKind_OTHER,
    SqlTypeName sqlTypeName = SqlTypeName_ANY,
    const std::vector<int8_t> *data = nullptr) {
  return com::blazingdb::protocol::calcite::plan::messages::CreateRexNode(
      _fbb,
      type,
      sqlKind,
      sqlTypeName,
      data ? _fbb.CreateVector<int8_t>(*data) : 0);
}

}  // namespace messages
}  // namespace plan
}  // namespace calcite
}  // namespace protocol
}  // namespace blazingdb
}  // namespace com

namespace blazingdb {
namespace protocol {
namespace calcite {

struct DMLResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOGICALPLAN = 4,
    VT_TIME = 6
  };
  const flatbuffers::String *logicalPlan() const {
    return GetPointer<const flatbuffers::String *>(VT_LOGICALPLAN);
  }
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOGICALPLAN) &&
           verifier.Verify(logicalPlan()) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct DMLResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_logicalPlan(flatbuffers::Offset<flatbuffers::String> logicalPlan) {
    fbb_.AddOffset(DMLResponse::VT_LOGICALPLAN, logicalPlan);
  }
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(DMLResponse::VT_TIME, time, 0);
  }
  explicit DMLResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DMLResponseBuilder &operator=(const DMLResponseBuilder &);
  flatbuffers::Offset<DMLResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DMLResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DMLResponse> CreateDMLResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> logicalPlan = 0,
    int64_t time = 0) {
  DMLResponseBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_logicalPlan(logicalPlan);
  return builder_.Finish();
}

inline flatbuffers::Offset<DMLResponse> CreateDMLResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *logicalPlan = nullptr,
    int64_t time = 0) {
  return blazingdb::protocol::calcite::CreateDMLResponse(
      _fbb,
      logicalPlan ? _fbb.CreateString(logicalPlan) : 0,
      time);
}

struct DDLResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIME = 4
  };
  int64_t time() const {
    return GetField<int64_t>(VT_TIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIME) &&
           verifier.EndTable();
  }
};

struct DDLResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int64_t time) {
    fbb_.AddElement<int64_t>(DDLResponse::VT_TIME, time, 0);
  }
  explicit DDLResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLResponseBuilder &operator=(const DDLResponseBuilder &);
  flatbuffers::Offset<DDLResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLResponse> CreateDDLResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t time = 0) {
  DDLResponseBuilder builder_(_fbb);
  builder_.add_time(time);
  return builder_.Finish();
}

}  // namespace calcite

namespace orchestrator {

struct AuthResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCESSTOKEN = 4
  };
  uint64_t accessToken() const {
    return GetField<uint64_t>(VT_ACCESSTOKEN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ACCESSTOKEN) &&
           verifier.EndTable();
  }
};

struct AuthResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accessToken(uint64_t accessToken) {
    fbb_.AddElement<uint64_t>(AuthResponse::VT_ACCESSTOKEN, accessToken, 0);
  }
  explicit AuthResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthResponseBuilder &operator=(const AuthResponseBuilder &);
  flatbuffers::Offset<AuthResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AuthResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuthResponse> CreateAuthResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t accessToken = 0) {
  AuthResponseBuilder builder_(_fbb);
  builder_.add_accessToken(accessToken);
  return builder_.Finish();
}

}  // namespace orchestrator

struct NodeConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PATH = 4,
    VT_TYPE = 6
  };
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  NodeConnectionType type() const {
    return static_cast<NodeConnectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.Verify(path()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct NodeConnectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(NodeConnection::VT_PATH, path);
  }
  void add_type(NodeConnectionType type) {
    fbb_.AddElement<int8_t>(NodeConnection::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit NodeConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeConnectionBuilder &operator=(const NodeConnectionBuilder &);
  flatbuffers::Offset<NodeConnection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodeConnection>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodeConnection> CreateNodeConnection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    NodeConnectionType type = NodeConnectionType_TPC) {
  NodeConnectionBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeConnection> CreateNodeConnectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    NodeConnectionType type = NodeConnectionType_TPC) {
  return blazingdb::protocol::CreateNodeConnection(
      _fbb,
      path ? _fbb.CreateString(path) : 0,
      type);
}

namespace orchestrator {

struct DMLResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULTTOKEN = 4,
    VT_NODECONNECTION = 6,
    VT_CALCITETIME = 8
  };
  uint64_t resultToken() const {
    return GetField<uint64_t>(VT_RESULTTOKEN, 0);
  }
  const blazingdb::protocol::NodeConnection *nodeConnection() const {
    return GetPointer<const blazingdb::protocol::NodeConnection *>(VT_NODECONNECTION);
  }
  int64_t calciteTime() const {
    return GetField<int64_t>(VT_CALCITETIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RESULTTOKEN) &&
           VerifyOffset(verifier, VT_NODECONNECTION) &&
           verifier.VerifyTable(nodeConnection()) &&
           VerifyField<int64_t>(verifier, VT_CALCITETIME) &&
           verifier.EndTable();
  }
};

struct DMLResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_resultToken(uint64_t resultToken) {
    fbb_.AddElement<uint64_t>(DMLResponse::VT_RESULTTOKEN, resultToken, 0);
  }
  void add_nodeConnection(flatbuffers::Offset<blazingdb::protocol::NodeConnection> nodeConnection) {
    fbb_.AddOffset(DMLResponse::VT_NODECONNECTION, nodeConnection);
  }
  void add_calciteTime(int64_t calciteTime) {
    fbb_.AddElement<int64_t>(DMLResponse::VT_CALCITETIME, calciteTime, 0);
  }
  explicit DMLResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DMLResponseBuilder &operator=(const DMLResponseBuilder &);
  flatbuffers::Offset<DMLResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DMLResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DMLResponse> CreateDMLResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t resultToken = 0,
    flatbuffers::Offset<blazingdb::protocol::NodeConnection> nodeConnection = 0,
    int64_t calciteTime = 0) {
  DMLResponseBuilder builder_(_fbb);
  builder_.add_calciteTime(calciteTime);
  builder_.add_resultToken(resultToken);
  builder_.add_nodeConnection(nodeConnection);
  return builder_.Finish();
}

struct DDLResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DDLResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DDLResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLResponseBuilder &operator=(const DDLResponseBuilder &);
  flatbuffers::Offset<DDLResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLResponse> CreateDDLResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DDLResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

}  // namespace orchestrator

namespace interpreter {

struct ExecutePlanResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULTTOKEN = 4,
    VT_NODECONNECTION = 6
  };
  uint64_t resultToken() const {
    return GetField<uint64_t>(VT_RESULTTOKEN, 0);
  }
  const blazingdb::protocol::NodeConnection *nodeConnection() const {
    return GetPointer<const blazingdb::protocol::NodeConnection *>(VT_NODECONNECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RESULTTOKEN) &&
           VerifyOffset(verifier, VT_NODECONNECTION) &&
           verifier.VerifyTable(nodeConnection()) &&
           verifier.EndTable();
  }
};

struct ExecutePlanResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_resultToken(uint64_t resultToken) {
    fbb_.AddElement<uint64_t>(ExecutePlanResponse::VT_RESULTTOKEN, resultToken, 0);
  }
  void add_nodeConnection(flatbuffers::Offset<blazingdb::protocol::NodeConnection> nodeConnection) {
    fbb_.AddOffset(ExecutePlanResponse::VT_NODECONNECTION, nodeConnection);
  }
  explicit ExecutePlanResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExecutePlanResponseBuilder &operator=(const ExecutePlanResponseBuilder &);
  flatbuffers::Offset<ExecutePlanResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutePlanResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutePlanResponse> CreateExecutePlanResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t resultToken = 0,
    flatbuffers::Offset<blazingdb::protocol::NodeConnection> nodeConnection = 0) {
  ExecutePlanResponseBuilder builder_(_fbb);
  builder_.add_resultToken(resultToken);
  builder_.add_nodeConnection(nodeConnection);
  return builder_.Finish();
}

struct BlazingMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATUS = 4,
    VT_MESSAGE = 6,
    VT_TIME = 8,
    VT_ROWS = 10
  };
  const flatbuffers::String *status() const {
    return GetPointer<const flatbuffers::String *>(VT_STATUS);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  int32_t rows() const {
    return GetField<int32_t>(VT_ROWS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.Verify(status()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyField<int32_t>(verifier, VT_ROWS) &&
           verifier.EndTable();
  }
};

struct BlazingMetadataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(flatbuffers::Offset<flatbuffers::String> status) {
    fbb_.AddOffset(BlazingMetadata::VT_STATUS, status);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(BlazingMetadata::VT_MESSAGE, message);
  }
  void add_time(double time) {
    fbb_.AddElement<double>(BlazingMetadata::VT_TIME, time, 0.0);
  }
  void add_rows(int32_t rows) {
    fbb_.AddElement<int32_t>(BlazingMetadata::VT_ROWS, rows, 0);
  }
  explicit BlazingMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlazingMetadataBuilder &operator=(const BlazingMetadataBuilder &);
  flatbuffers::Offset<BlazingMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlazingMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlazingMetadata> CreateBlazingMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> status = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    double time = 0.0,
    int32_t rows = 0) {
  BlazingMetadataBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_rows(rows);
  builder_.add_message(message);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlazingMetadata> CreateBlazingMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *status = nullptr,
    const char *message = nullptr,
    double time = 0.0,
    int32_t rows = 0) {
  return blazingdb::protocol::interpreter::CreateBlazingMetadata(
      _fbb,
      status ? _fbb.CreateString(status) : 0,
      message ? _fbb.CreateString(message) : 0,
      time,
      rows);
}

struct GetResultResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_METADATA = 4,
    VT_COLUMNS = 6,
    VT_COLUMNNAMES = 8
  };
  const BlazingMetadata *metadata() const {
    return GetPointer<const BlazingMetadata *>(VT_METADATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>> *columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>> *>(VT_COLUMNS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNNAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.Verify(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           VerifyOffset(verifier, VT_COLUMNNAMES) &&
           verifier.Verify(columnNames()) &&
           verifier.VerifyVectorOfStrings(columnNames()) &&
           verifier.EndTable();
  }
};

struct GetResultResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_metadata(flatbuffers::Offset<BlazingMetadata> metadata) {
    fbb_.AddOffset(GetResultResponse::VT_METADATA, metadata);
  }
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>>> columns) {
    fbb_.AddOffset(GetResultResponse::VT_COLUMNS, columns);
  }
  void add_columnNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames) {
    fbb_.AddOffset(GetResultResponse::VT_COLUMNNAMES, columnNames);
  }
  explicit GetResultResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetResultResponseBuilder &operator=(const GetResultResponseBuilder &);
  flatbuffers::Offset<GetResultResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetResultResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetResultResponse> CreateGetResultResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<BlazingMetadata> metadata = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>>> columns = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames = 0) {
  GetResultResponseBuilder builder_(_fbb);
  builder_.add_columnNames(columnNames);
  builder_.add_columns(columns);
  builder_.add_metadata(metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetResultResponse> CreateGetResultResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<BlazingMetadata> metadata = 0,
    const std::vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>> *columns = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnNames = nullptr) {
  return blazingdb::protocol::interpreter::CreateGetResultResponse(
      _fbb,
      metadata,
      columns ? _fbb.CreateVector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>>(*columns) : 0,
      columnNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnNames) : 0);
}

}  // namespace interpreter

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATUS = 4,
    VT_PAYLOAD = 6
  };
  Status status() const {
    return static_cast<Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  const flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.Verify(payload()) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(Status status) {
    fbb_.AddElement<int8_t>(Response::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(Response::VT_PAYLOAD, payload);
  }
  explicit ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    Status status = Status_Error,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response> CreateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Status status = Status_Error,
    const std::vector<uint8_t> *payload = nullptr) {
  return blazingdb::protocol::CreateResponse(
      _fbb,
      status,
      payload ? _fbb.CreateVector<uint8_t>(*payload) : 0);
}

struct ResponseError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORS = 4
  };
  const flatbuffers::String *errors() const {
    return GetPointer<const flatbuffers::String *>(VT_ERRORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERRORS) &&
           verifier.Verify(errors()) &&
           verifier.EndTable();
  }
};

struct ResponseErrorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errors(flatbuffers::Offset<flatbuffers::String> errors) {
    fbb_.AddOffset(ResponseError::VT_ERRORS, errors);
  }
  explicit ResponseErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseErrorBuilder &operator=(const ResponseErrorBuilder &);
  flatbuffers::Offset<ResponseError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResponseError>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResponseError> CreateResponseError(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> errors = 0) {
  ResponseErrorBuilder builder_(_fbb);
  builder_.add_errors(errors);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResponseError> CreateResponseErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *errors = nullptr) {
  return blazingdb::protocol::CreateResponseError(
      _fbb,
      errors ? _fbb.CreateString(errors) : 0);
}

namespace calcite {

}  // namespace calcite

namespace orchestrator {

}  // namespace orchestrator

namespace gdf {

}  // namespace gdf

namespace orchestrator {

}  // namespace orchestrator

namespace interpreter {

}  // namespace interpreter

}  // namespace protocol
}  // namespace blazingdb

namespace com {
namespace blazingdb {
namespace protocol {
namespace calcite {
namespace plan {
namespace messages {

}  // namespace messages
}  // namespace plan
}  // namespace calcite
}  // namespace protocol
}  // namespace blazingdb
}  // namespace com

namespace blazingdb {
namespace protocol {
namespace calcite {

}  // namespace calcite

namespace orchestrator {

}  // namespace orchestrator

namespace orchestrator {

}  // namespace orchestrator

namespace interpreter {

}  // namespace interpreter

}  // namespace protocol
}  // namespace blazingdb

#endif  // FLATBUFFERS_GENERATED_ALL_H_
