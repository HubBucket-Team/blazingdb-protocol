// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ALL_H_
#define FLATBUFFERS_GENERATED_ALL_H_

#include "flatbuffers/flatbuffers.h"

namespace blazingdb {
namespace protocol {
namespace calcite {

struct DMLRequest;

struct DDLRequest;

struct DDLCreateTableRequest;

struct DDLDropTableRequest;

}  // namespace calcite

namespace orchestrator {

struct DDLCreateTableRequest;

struct DDLDropTableRequest;

struct AuthRequest;

}  // namespace orchestrator

namespace gdf {

struct gdf_dtype_extra_info;

struct cudaIpcMemHandle_t;

struct gdf_column_handler;

}  // namespace gdf

struct BlazingTable;

struct TableGroup;

namespace orchestrator {

struct DMLRequest;

struct DDLRequest;

}  // namespace orchestrator

namespace interpreter {

struct DMLRequest;

struct GetResultRequest;

}  // namespace interpreter

struct Header;

struct Request;

namespace calcite {

struct DMLResponse;

struct DDLResponse;

}  // namespace calcite

namespace orchestrator {

struct AuthResponse;

struct DMLResponse;

struct DDLResponse;

}  // namespace orchestrator

namespace interpreter {

struct NodeConnectionInformation;

struct ExecutePlanResponse;

struct BlazingMetadata;

struct GetResultResponse;

}  // namespace interpreter

struct Response;

struct ResponseError;

namespace calcite {

enum MessageType {
  MessageType_DDL = 0,
  MessageType_DML = 1,
  MessageType_DDL_CREATE_TABLE = 2,
  MessageType_DDL_DROP_TABLE = 3,
  MessageType_MIN = MessageType_DDL,
  MessageType_MAX = MessageType_DDL_DROP_TABLE
};

inline const MessageType (&EnumValuesMessageType())[4] {
  static const MessageType values[] = {
    MessageType_DDL,
    MessageType_DML,
    MessageType_DDL_CREATE_TABLE,
    MessageType_DDL_DROP_TABLE
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[] = {
    "DDL",
    "DML",
    "DDL_CREATE_TABLE",
    "DDL_DROP_TABLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageType()[index];
}

}  // namespace calcite

namespace orchestrator {

enum MessageType {
  MessageType_DDL = 0,
  MessageType_DML = 1,
  MessageType_DDL_CREATE_TABLE = 2,
  MessageType_DDL_DROP_TABLE = 3,
  MessageType_AuthOpen = 4,
  MessageType_AuthClose = 5,
  MessageType_MIN = MessageType_DDL,
  MessageType_MAX = MessageType_AuthClose
};

inline const MessageType (&EnumValuesMessageType())[6] {
  static const MessageType values[] = {
    MessageType_DDL,
    MessageType_DML,
    MessageType_DDL_CREATE_TABLE,
    MessageType_DDL_DROP_TABLE,
    MessageType_AuthOpen,
    MessageType_AuthClose
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[] = {
    "DDL",
    "DML",
    "DDL_CREATE_TABLE",
    "DDL_DROP_TABLE",
    "AuthOpen",
    "AuthClose",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageType()[index];
}

}  // namespace orchestrator

namespace gdf {

enum gdf_dtype {
  gdf_dtype_GDF_invalid = 0,
  gdf_dtype_GDF_INT8 = 1,
  gdf_dtype_GDF_INT16 = 2,
  gdf_dtype_GDF_INT32 = 3,
  gdf_dtype_GDF_INT64 = 4,
  gdf_dtype_GDF_UINT8 = 5,
  gdf_dtype_GDF_UINT16 = 6,
  gdf_dtype_GDF_UINT32 = 7,
  gdf_dtype_GDF_UINT64 = 8,
  gdf_dtype_GDF_FLOAT32 = 9,
  gdf_dtype_GDF_FLOAT64 = 10,
  gdf_dtype_GDF_DATE32 = 11,
  gdf_dtype_GDF_DATE64 = 12,
  gdf_dtype_GDF_TIMESTAMP = 13,
  gdf_dtype_N_GDF_TYPES = 14,
  gdf_dtype_MIN = gdf_dtype_GDF_invalid,
  gdf_dtype_MAX = gdf_dtype_N_GDF_TYPES
};

inline const gdf_dtype (&EnumValuesgdf_dtype())[15] {
  static const gdf_dtype values[] = {
    gdf_dtype_GDF_invalid,
    gdf_dtype_GDF_INT8,
    gdf_dtype_GDF_INT16,
    gdf_dtype_GDF_INT32,
    gdf_dtype_GDF_INT64,
    gdf_dtype_GDF_UINT8,
    gdf_dtype_GDF_UINT16,
    gdf_dtype_GDF_UINT32,
    gdf_dtype_GDF_UINT64,
    gdf_dtype_GDF_FLOAT32,
    gdf_dtype_GDF_FLOAT64,
    gdf_dtype_GDF_DATE32,
    gdf_dtype_GDF_DATE64,
    gdf_dtype_GDF_TIMESTAMP,
    gdf_dtype_N_GDF_TYPES
  };
  return values;
}

inline const char * const *EnumNamesgdf_dtype() {
  static const char * const names[] = {
    "GDF_invalid",
    "GDF_INT8",
    "GDF_INT16",
    "GDF_INT32",
    "GDF_INT64",
    "GDF_UINT8",
    "GDF_UINT16",
    "GDF_UINT32",
    "GDF_UINT64",
    "GDF_FLOAT32",
    "GDF_FLOAT64",
    "GDF_DATE32",
    "GDF_DATE64",
    "GDF_TIMESTAMP",
    "N_GDF_TYPES",
    nullptr
  };
  return names;
}

inline const char *EnumNamegdf_dtype(gdf_dtype e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesgdf_dtype()[index];
}

enum gdf_time_unit {
  gdf_time_unit_TIME_UNIT_NONE = 0,
  gdf_time_unit_TIME_UNIT_s = 1,
  gdf_time_unit_TIME_UNIT_ms = 2,
  gdf_time_unit_TIME_UNIT_us = 3,
  gdf_time_unit_TIME_UNIT_ns = 4,
  gdf_time_unit_MIN = gdf_time_unit_TIME_UNIT_NONE,
  gdf_time_unit_MAX = gdf_time_unit_TIME_UNIT_ns
};

inline const gdf_time_unit (&EnumValuesgdf_time_unit())[5] {
  static const gdf_time_unit values[] = {
    gdf_time_unit_TIME_UNIT_NONE,
    gdf_time_unit_TIME_UNIT_s,
    gdf_time_unit_TIME_UNIT_ms,
    gdf_time_unit_TIME_UNIT_us,
    gdf_time_unit_TIME_UNIT_ns
  };
  return values;
}

inline const char * const *EnumNamesgdf_time_unit() {
  static const char * const names[] = {
    "TIME_UNIT_NONE",
    "TIME_UNIT_s",
    "TIME_UNIT_ms",
    "TIME_UNIT_us",
    "TIME_UNIT_ns",
    nullptr
  };
  return names;
}

inline const char *EnumNamegdf_time_unit(gdf_time_unit e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesgdf_time_unit()[index];
}

}  // namespace gdf

namespace interpreter {

enum MessageType {
  MessageType_ExecutePlan = 0,
  MessageType_GetResult = 1,
  MessageType_FreeResult = 2,
  MessageType_CloseConnection = 3,
  MessageType_MIN = MessageType_ExecutePlan,
  MessageType_MAX = MessageType_CloseConnection
};

inline const MessageType (&EnumValuesMessageType())[4] {
  static const MessageType values[] = {
    MessageType_ExecutePlan,
    MessageType_GetResult,
    MessageType_FreeResult,
    MessageType_CloseConnection
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[] = {
    "ExecutePlan",
    "GetResult",
    "FreeResult",
    "CloseConnection",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageType()[index];
}

enum NodeConnectionType {
  NodeConnectionType_TPC = 0,
  NodeConnectionType_IPC = 1,
  NodeConnectionType_MIN = NodeConnectionType_TPC,
  NodeConnectionType_MAX = NodeConnectionType_IPC
};

inline const NodeConnectionType (&EnumValuesNodeConnectionType())[2] {
  static const NodeConnectionType values[] = {
    NodeConnectionType_TPC,
    NodeConnectionType_IPC
  };
  return values;
}

inline const char * const *EnumNamesNodeConnectionType() {
  static const char * const names[] = {
    "TPC",
    "IPC",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeConnectionType(NodeConnectionType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesNodeConnectionType()[index];
}

}  // namespace interpreter

enum Status {
  Status_Error = 0,
  Status_Success = 1,
  Status_MIN = Status_Error,
  Status_MAX = Status_Success
};

inline const Status (&EnumValuesStatus())[2] {
  static const Status values[] = {
    Status_Error,
    Status_Success
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[] = {
    "Error",
    "Success",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesStatus()[index];
}

MANUALLY_ALIGNED_STRUCT(8) Header FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t messageType_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;
  uint64_t accessToken_;

 public:
  Header() {
    memset(this, 0, sizeof(Header));
  }
  Header(int8_t _messageType, uint64_t _accessToken)
      : messageType_(flatbuffers::EndianScalar(_messageType)),
        padding0__(0),
        padding1__(0),
        padding2__(0),
        accessToken_(flatbuffers::EndianScalar(_accessToken)) {
    (void)padding0__;    (void)padding1__;    (void)padding2__;
  }
  int8_t messageType() const {
    return flatbuffers::EndianScalar(messageType_);
  }
  uint64_t accessToken() const {
    return flatbuffers::EndianScalar(accessToken_);
  }
};
STRUCT_END(Header, 16);

namespace calcite {

struct DMLRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUERY = 4
  };
  const flatbuffers::String *query() const {
    return GetPointer<const flatbuffers::String *>(VT_QUERY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.Verify(query()) &&
           verifier.EndTable();
  }
};

struct DMLRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_query(flatbuffers::Offset<flatbuffers::String> query) {
    fbb_.AddOffset(DMLRequest::VT_QUERY, query);
  }
  explicit DMLRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DMLRequestBuilder &operator=(const DMLRequestBuilder &);
  flatbuffers::Offset<DMLRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DMLRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DMLRequest> CreateDMLRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> query = 0) {
  DMLRequestBuilder builder_(_fbb);
  builder_.add_query(query);
  return builder_.Finish();
}

inline flatbuffers::Offset<DMLRequest> CreateDMLRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *query = nullptr) {
  return blazingdb::protocol::calcite::CreateDMLRequest(
      _fbb,
      query ? _fbb.CreateString(query) : 0);
}

struct DDLRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUERY = 4
  };
  const flatbuffers::String *query() const {
    return GetPointer<const flatbuffers::String *>(VT_QUERY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.Verify(query()) &&
           verifier.EndTable();
  }
};

struct DDLRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_query(flatbuffers::Offset<flatbuffers::String> query) {
    fbb_.AddOffset(DDLRequest::VT_QUERY, query);
  }
  explicit DDLRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLRequestBuilder &operator=(const DDLRequestBuilder &);
  flatbuffers::Offset<DDLRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLRequest> CreateDDLRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> query = 0) {
  DDLRequestBuilder builder_(_fbb);
  builder_.add_query(query);
  return builder_.Finish();
}

inline flatbuffers::Offset<DDLRequest> CreateDDLRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *query = nullptr) {
  return blazingdb::protocol::calcite::CreateDDLRequest(
      _fbb,
      query ? _fbb.CreateString(query) : 0);
}

struct DDLCreateTableRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_COLUMNNAMES = 6,
    VT_COLUMNTYPES = 8,
    VT_DBNAME = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNNAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnTypes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNTYPES);
  }
  const flatbuffers::String *dbName() const {
    return GetPointer<const flatbuffers::String *>(VT_DBNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_COLUMNNAMES) &&
           verifier.Verify(columnNames()) &&
           verifier.VerifyVectorOfStrings(columnNames()) &&
           VerifyOffset(verifier, VT_COLUMNTYPES) &&
           verifier.Verify(columnTypes()) &&
           verifier.VerifyVectorOfStrings(columnTypes()) &&
           VerifyOffset(verifier, VT_DBNAME) &&
           verifier.Verify(dbName()) &&
           verifier.EndTable();
  }
};

struct DDLCreateTableRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_NAME, name);
  }
  void add_columnNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_COLUMNNAMES, columnNames);
  }
  void add_columnTypes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnTypes) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_COLUMNTYPES, columnTypes);
  }
  void add_dbName(flatbuffers::Offset<flatbuffers::String> dbName) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_DBNAME, dbName);
  }
  explicit DDLCreateTableRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLCreateTableRequestBuilder &operator=(const DDLCreateTableRequestBuilder &);
  flatbuffers::Offset<DDLCreateTableRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLCreateTableRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLCreateTableRequest> CreateDDLCreateTableRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnTypes = 0,
    flatbuffers::Offset<flatbuffers::String> dbName = 0) {
  DDLCreateTableRequestBuilder builder_(_fbb);
  builder_.add_dbName(dbName);
  builder_.add_columnTypes(columnTypes);
  builder_.add_columnNames(columnNames);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<DDLCreateTableRequest> CreateDDLCreateTableRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnNames = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnTypes = nullptr,
    const char *dbName = nullptr) {
  return blazingdb::protocol::calcite::CreateDDLCreateTableRequest(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      columnNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnNames) : 0,
      columnTypes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnTypes) : 0,
      dbName ? _fbb.CreateString(dbName) : 0);
}

struct DDLDropTableRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_DBNAME = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *dbName() const {
    return GetPointer<const flatbuffers::String *>(VT_DBNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_DBNAME) &&
           verifier.Verify(dbName()) &&
           verifier.EndTable();
  }
};

struct DDLDropTableRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DDLDropTableRequest::VT_NAME, name);
  }
  void add_dbName(flatbuffers::Offset<flatbuffers::String> dbName) {
    fbb_.AddOffset(DDLDropTableRequest::VT_DBNAME, dbName);
  }
  explicit DDLDropTableRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLDropTableRequestBuilder &operator=(const DDLDropTableRequestBuilder &);
  flatbuffers::Offset<DDLDropTableRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLDropTableRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLDropTableRequest> CreateDDLDropTableRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> dbName = 0) {
  DDLDropTableRequestBuilder builder_(_fbb);
  builder_.add_dbName(dbName);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<DDLDropTableRequest> CreateDDLDropTableRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *dbName = nullptr) {
  return blazingdb::protocol::calcite::CreateDDLDropTableRequest(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      dbName ? _fbb.CreateString(dbName) : 0);
}

}  // namespace calcite

namespace orchestrator {

struct DDLCreateTableRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_COLUMNNAMES = 6,
    VT_COLUMNTYPES = 8,
    VT_DBNAME = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNNAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnTypes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNTYPES);
  }
  const flatbuffers::String *dbName() const {
    return GetPointer<const flatbuffers::String *>(VT_DBNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_COLUMNNAMES) &&
           verifier.Verify(columnNames()) &&
           verifier.VerifyVectorOfStrings(columnNames()) &&
           VerifyOffset(verifier, VT_COLUMNTYPES) &&
           verifier.Verify(columnTypes()) &&
           verifier.VerifyVectorOfStrings(columnTypes()) &&
           VerifyOffset(verifier, VT_DBNAME) &&
           verifier.Verify(dbName()) &&
           verifier.EndTable();
  }
};

struct DDLCreateTableRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_NAME, name);
  }
  void add_columnNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_COLUMNNAMES, columnNames);
  }
  void add_columnTypes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnTypes) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_COLUMNTYPES, columnTypes);
  }
  void add_dbName(flatbuffers::Offset<flatbuffers::String> dbName) {
    fbb_.AddOffset(DDLCreateTableRequest::VT_DBNAME, dbName);
  }
  explicit DDLCreateTableRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLCreateTableRequestBuilder &operator=(const DDLCreateTableRequestBuilder &);
  flatbuffers::Offset<DDLCreateTableRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLCreateTableRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLCreateTableRequest> CreateDDLCreateTableRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnTypes = 0,
    flatbuffers::Offset<flatbuffers::String> dbName = 0) {
  DDLCreateTableRequestBuilder builder_(_fbb);
  builder_.add_dbName(dbName);
  builder_.add_columnTypes(columnTypes);
  builder_.add_columnNames(columnNames);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<DDLCreateTableRequest> CreateDDLCreateTableRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnNames = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnTypes = nullptr,
    const char *dbName = nullptr) {
  return blazingdb::protocol::orchestrator::CreateDDLCreateTableRequest(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      columnNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnNames) : 0,
      columnTypes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnTypes) : 0,
      dbName ? _fbb.CreateString(dbName) : 0);
}

struct DDLDropTableRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_DBNAME = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *dbName() const {
    return GetPointer<const flatbuffers::String *>(VT_DBNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_DBNAME) &&
           verifier.Verify(dbName()) &&
           verifier.EndTable();
  }
};

struct DDLDropTableRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DDLDropTableRequest::VT_NAME, name);
  }
  void add_dbName(flatbuffers::Offset<flatbuffers::String> dbName) {
    fbb_.AddOffset(DDLDropTableRequest::VT_DBNAME, dbName);
  }
  explicit DDLDropTableRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLDropTableRequestBuilder &operator=(const DDLDropTableRequestBuilder &);
  flatbuffers::Offset<DDLDropTableRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLDropTableRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLDropTableRequest> CreateDDLDropTableRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> dbName = 0) {
  DDLDropTableRequestBuilder builder_(_fbb);
  builder_.add_dbName(dbName);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<DDLDropTableRequest> CreateDDLDropTableRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *dbName = nullptr) {
  return blazingdb::protocol::orchestrator::CreateDDLDropTableRequest(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      dbName ? _fbb.CreateString(dbName) : 0);
}

struct AuthRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AuthRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AuthRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthRequestBuilder &operator=(const AuthRequestBuilder &);
  flatbuffers::Offset<AuthRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AuthRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuthRequest> CreateAuthRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AuthRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

}  // namespace orchestrator

namespace gdf {

struct gdf_dtype_extra_info FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIME_UNIT = 4
  };
  gdf_time_unit time_unit() const {
    return static_cast<gdf_time_unit>(GetField<int8_t>(VT_TIME_UNIT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TIME_UNIT) &&
           verifier.EndTable();
  }
};

struct gdf_dtype_extra_infoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_unit(gdf_time_unit time_unit) {
    fbb_.AddElement<int8_t>(gdf_dtype_extra_info::VT_TIME_UNIT, static_cast<int8_t>(time_unit), 0);
  }
  explicit gdf_dtype_extra_infoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gdf_dtype_extra_infoBuilder &operator=(const gdf_dtype_extra_infoBuilder &);
  flatbuffers::Offset<gdf_dtype_extra_info> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gdf_dtype_extra_info>(end);
    return o;
  }
};

inline flatbuffers::Offset<gdf_dtype_extra_info> Creategdf_dtype_extra_info(
    flatbuffers::FlatBufferBuilder &_fbb,
    gdf_time_unit time_unit = gdf_time_unit_TIME_UNIT_NONE) {
  gdf_dtype_extra_infoBuilder builder_(_fbb);
  builder_.add_time_unit(time_unit);
  return builder_.Finish();
}

struct cudaIpcMemHandle_t FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESERVED = 4
  };
  const flatbuffers::Vector<int8_t> *reserved() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_RESERVED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESERVED) &&
           verifier.Verify(reserved()) &&
           verifier.EndTable();
  }
};

struct cudaIpcMemHandle_tBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reserved(flatbuffers::Offset<flatbuffers::Vector<int8_t>> reserved) {
    fbb_.AddOffset(cudaIpcMemHandle_t::VT_RESERVED, reserved);
  }
  explicit cudaIpcMemHandle_tBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  cudaIpcMemHandle_tBuilder &operator=(const cudaIpcMemHandle_tBuilder &);
  flatbuffers::Offset<cudaIpcMemHandle_t> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<cudaIpcMemHandle_t>(end);
    return o;
  }
};

inline flatbuffers::Offset<cudaIpcMemHandle_t> CreatecudaIpcMemHandle_t(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> reserved = 0) {
  cudaIpcMemHandle_tBuilder builder_(_fbb);
  builder_.add_reserved(reserved);
  return builder_.Finish();
}

inline flatbuffers::Offset<cudaIpcMemHandle_t> CreatecudaIpcMemHandle_tDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *reserved = nullptr) {
  return blazingdb::protocol::gdf::CreatecudaIpcMemHandle_t(
      _fbb,
      reserved ? _fbb.CreateVector<int8_t>(*reserved) : 0);
}

struct gdf_column_handler FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4,
    VT_VALID = 6,
    VT_SIZE = 8,
    VT_DTYPE = 10,
    VT_DTYPE_INFO = 12,
    VT_NULL_COUNT = 14
  };
  const cudaIpcMemHandle_t *data() const {
    return GetPointer<const cudaIpcMemHandle_t *>(VT_DATA);
  }
  const cudaIpcMemHandle_t *valid() const {
    return GetPointer<const cudaIpcMemHandle_t *>(VT_VALID);
  }
  uint16_t size() const {
    return GetField<uint16_t>(VT_SIZE, 0);
  }
  gdf_dtype dtype() const {
    return static_cast<gdf_dtype>(GetField<int8_t>(VT_DTYPE, 0));
  }
  const gdf_dtype_extra_info *dtype_info() const {
    return GetPointer<const gdf_dtype_extra_info *>(VT_DTYPE_INFO);
  }
  uint16_t null_count() const {
    return GetField<uint16_t>(VT_NULL_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           VerifyOffset(verifier, VT_VALID) &&
           verifier.VerifyTable(valid()) &&
           VerifyField<uint16_t>(verifier, VT_SIZE) &&
           VerifyField<int8_t>(verifier, VT_DTYPE) &&
           VerifyOffset(verifier, VT_DTYPE_INFO) &&
           verifier.VerifyTable(dtype_info()) &&
           VerifyField<uint16_t>(verifier, VT_NULL_COUNT) &&
           verifier.EndTable();
  }
};

struct gdf_column_handlerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<cudaIpcMemHandle_t> data) {
    fbb_.AddOffset(gdf_column_handler::VT_DATA, data);
  }
  void add_valid(flatbuffers::Offset<cudaIpcMemHandle_t> valid) {
    fbb_.AddOffset(gdf_column_handler::VT_VALID, valid);
  }
  void add_size(uint16_t size) {
    fbb_.AddElement<uint16_t>(gdf_column_handler::VT_SIZE, size, 0);
  }
  void add_dtype(gdf_dtype dtype) {
    fbb_.AddElement<int8_t>(gdf_column_handler::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  void add_dtype_info(flatbuffers::Offset<gdf_dtype_extra_info> dtype_info) {
    fbb_.AddOffset(gdf_column_handler::VT_DTYPE_INFO, dtype_info);
  }
  void add_null_count(uint16_t null_count) {
    fbb_.AddElement<uint16_t>(gdf_column_handler::VT_NULL_COUNT, null_count, 0);
  }
  explicit gdf_column_handlerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  gdf_column_handlerBuilder &operator=(const gdf_column_handlerBuilder &);
  flatbuffers::Offset<gdf_column_handler> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<gdf_column_handler>(end);
    return o;
  }
};

inline flatbuffers::Offset<gdf_column_handler> Creategdf_column_handler(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<cudaIpcMemHandle_t> data = 0,
    flatbuffers::Offset<cudaIpcMemHandle_t> valid = 0,
    uint16_t size = 0,
    gdf_dtype dtype = gdf_dtype_GDF_invalid,
    flatbuffers::Offset<gdf_dtype_extra_info> dtype_info = 0,
    uint16_t null_count = 0) {
  gdf_column_handlerBuilder builder_(_fbb);
  builder_.add_dtype_info(dtype_info);
  builder_.add_valid(valid);
  builder_.add_data(data);
  builder_.add_null_count(null_count);
  builder_.add_size(size);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

}  // namespace gdf

struct BlazingTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_COLUMNS = 6,
    VT_COLUMNNAMES = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>> *columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>> *>(VT_COLUMNS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNNAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.Verify(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           VerifyOffset(verifier, VT_COLUMNNAMES) &&
           verifier.Verify(columnNames()) &&
           verifier.VerifyVectorOfStrings(columnNames()) &&
           verifier.EndTable();
  }
};

struct BlazingTableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(BlazingTable::VT_NAME, name);
  }
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>>> columns) {
    fbb_.AddOffset(BlazingTable::VT_COLUMNS, columns);
  }
  void add_columnNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames) {
    fbb_.AddOffset(BlazingTable::VT_COLUMNNAMES, columnNames);
  }
  explicit BlazingTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlazingTableBuilder &operator=(const BlazingTableBuilder &);
  flatbuffers::Offset<BlazingTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlazingTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlazingTable> CreateBlazingTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>>> columns = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames = 0) {
  BlazingTableBuilder builder_(_fbb);
  builder_.add_columnNames(columnNames);
  builder_.add_columns(columns);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlazingTable> CreateBlazingTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>> *columns = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnNames = nullptr) {
  return blazingdb::protocol::CreateBlazingTable(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      columns ? _fbb.CreateVector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>>(*columns) : 0,
      columnNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnNames) : 0);
}

struct TableGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TABLES = 4,
    VT_NAME = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<BlazingTable>> *tables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BlazingTable>> *>(VT_TABLES);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TABLES) &&
           verifier.Verify(tables()) &&
           verifier.VerifyVectorOfTables(tables()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct TableGroupBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BlazingTable>>> tables) {
    fbb_.AddOffset(TableGroup::VT_TABLES, tables);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TableGroup::VT_NAME, name);
  }
  explicit TableGroupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableGroupBuilder &operator=(const TableGroupBuilder &);
  flatbuffers::Offset<TableGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableGroup>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableGroup> CreateTableGroup(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BlazingTable>>> tables = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  TableGroupBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_tables(tables);
  return builder_.Finish();
}

inline flatbuffers::Offset<TableGroup> CreateTableGroupDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BlazingTable>> *tables = nullptr,
    const char *name = nullptr) {
  return blazingdb::protocol::CreateTableGroup(
      _fbb,
      tables ? _fbb.CreateVector<flatbuffers::Offset<BlazingTable>>(*tables) : 0,
      name ? _fbb.CreateString(name) : 0);
}

namespace orchestrator {

struct DMLRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUERY = 4,
    VT_TABLEGROUP = 6
  };
  const flatbuffers::String *query() const {
    return GetPointer<const flatbuffers::String *>(VT_QUERY);
  }
  const blazingdb::protocol::TableGroup *tableGroup() const {
    return GetPointer<const blazingdb::protocol::TableGroup *>(VT_TABLEGROUP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.Verify(query()) &&
           VerifyOffset(verifier, VT_TABLEGROUP) &&
           verifier.VerifyTable(tableGroup()) &&
           verifier.EndTable();
  }
};

struct DMLRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_query(flatbuffers::Offset<flatbuffers::String> query) {
    fbb_.AddOffset(DMLRequest::VT_QUERY, query);
  }
  void add_tableGroup(flatbuffers::Offset<blazingdb::protocol::TableGroup> tableGroup) {
    fbb_.AddOffset(DMLRequest::VT_TABLEGROUP, tableGroup);
  }
  explicit DMLRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DMLRequestBuilder &operator=(const DMLRequestBuilder &);
  flatbuffers::Offset<DMLRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DMLRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DMLRequest> CreateDMLRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> query = 0,
    flatbuffers::Offset<blazingdb::protocol::TableGroup> tableGroup = 0) {
  DMLRequestBuilder builder_(_fbb);
  builder_.add_tableGroup(tableGroup);
  builder_.add_query(query);
  return builder_.Finish();
}

inline flatbuffers::Offset<DMLRequest> CreateDMLRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *query = nullptr,
    flatbuffers::Offset<blazingdb::protocol::TableGroup> tableGroup = 0) {
  return blazingdb::protocol::orchestrator::CreateDMLRequest(
      _fbb,
      query ? _fbb.CreateString(query) : 0,
      tableGroup);
}

struct DDLRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_QUERY = 4
  };
  const flatbuffers::String *query() const {
    return GetPointer<const flatbuffers::String *>(VT_QUERY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.Verify(query()) &&
           verifier.EndTable();
  }
};

struct DDLRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_query(flatbuffers::Offset<flatbuffers::String> query) {
    fbb_.AddOffset(DDLRequest::VT_QUERY, query);
  }
  explicit DDLRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLRequestBuilder &operator=(const DDLRequestBuilder &);
  flatbuffers::Offset<DDLRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLRequest> CreateDDLRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> query = 0) {
  DDLRequestBuilder builder_(_fbb);
  builder_.add_query(query);
  return builder_.Finish();
}

inline flatbuffers::Offset<DDLRequest> CreateDDLRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *query = nullptr) {
  return blazingdb::protocol::orchestrator::CreateDDLRequest(
      _fbb,
      query ? _fbb.CreateString(query) : 0);
}

}  // namespace orchestrator

namespace interpreter {

struct DMLRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOGICALPLAN = 4,
    VT_TABLEGROUP = 6
  };
  const flatbuffers::String *logicalPlan() const {
    return GetPointer<const flatbuffers::String *>(VT_LOGICALPLAN);
  }
  const blazingdb::protocol::TableGroup *tableGroup() const {
    return GetPointer<const blazingdb::protocol::TableGroup *>(VT_TABLEGROUP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOGICALPLAN) &&
           verifier.Verify(logicalPlan()) &&
           VerifyOffset(verifier, VT_TABLEGROUP) &&
           verifier.VerifyTable(tableGroup()) &&
           verifier.EndTable();
  }
};

struct DMLRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_logicalPlan(flatbuffers::Offset<flatbuffers::String> logicalPlan) {
    fbb_.AddOffset(DMLRequest::VT_LOGICALPLAN, logicalPlan);
  }
  void add_tableGroup(flatbuffers::Offset<blazingdb::protocol::TableGroup> tableGroup) {
    fbb_.AddOffset(DMLRequest::VT_TABLEGROUP, tableGroup);
  }
  explicit DMLRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DMLRequestBuilder &operator=(const DMLRequestBuilder &);
  flatbuffers::Offset<DMLRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DMLRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DMLRequest> CreateDMLRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> logicalPlan = 0,
    flatbuffers::Offset<blazingdb::protocol::TableGroup> tableGroup = 0) {
  DMLRequestBuilder builder_(_fbb);
  builder_.add_tableGroup(tableGroup);
  builder_.add_logicalPlan(logicalPlan);
  return builder_.Finish();
}

inline flatbuffers::Offset<DMLRequest> CreateDMLRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *logicalPlan = nullptr,
    flatbuffers::Offset<blazingdb::protocol::TableGroup> tableGroup = 0) {
  return blazingdb::protocol::interpreter::CreateDMLRequest(
      _fbb,
      logicalPlan ? _fbb.CreateString(logicalPlan) : 0,
      tableGroup);
}

struct GetResultRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULTTOKEN = 4
  };
  uint64_t resultToken() const {
    return GetField<uint64_t>(VT_RESULTTOKEN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RESULTTOKEN) &&
           verifier.EndTable();
  }
};

struct GetResultRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_resultToken(uint64_t resultToken) {
    fbb_.AddElement<uint64_t>(GetResultRequest::VT_RESULTTOKEN, resultToken, 0);
  }
  explicit GetResultRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetResultRequestBuilder &operator=(const GetResultRequestBuilder &);
  flatbuffers::Offset<GetResultRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetResultRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetResultRequest> CreateGetResultRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t resultToken = 0) {
  GetResultRequestBuilder builder_(_fbb);
  builder_.add_resultToken(resultToken);
  return builder_.Finish();
}

}  // namespace interpreter

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_PAYLOAD = 6
  };
  const Header *header() const {
    return GetStruct<const Header *>(VT_HEADER);
  }
  const flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Header>(verifier, VT_HEADER) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.Verify(payload()) &&
           verifier.EndTable();
  }
};

struct RequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(const Header *header) {
    fbb_.AddStruct(Request::VT_HEADER, header);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(Request::VT_PAYLOAD, payload);
  }
  explicit RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Header *header = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_header(header);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request> CreateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Header *header = 0,
    const std::vector<uint8_t> *payload = nullptr) {
  return blazingdb::protocol::CreateRequest(
      _fbb,
      header,
      payload ? _fbb.CreateVector<uint8_t>(*payload) : 0);
}

namespace calcite {

struct DMLResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOGICALPLAN = 4
  };
  const flatbuffers::String *logicalPlan() const {
    return GetPointer<const flatbuffers::String *>(VT_LOGICALPLAN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOGICALPLAN) &&
           verifier.Verify(logicalPlan()) &&
           verifier.EndTable();
  }
};

struct DMLResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_logicalPlan(flatbuffers::Offset<flatbuffers::String> logicalPlan) {
    fbb_.AddOffset(DMLResponse::VT_LOGICALPLAN, logicalPlan);
  }
  explicit DMLResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DMLResponseBuilder &operator=(const DMLResponseBuilder &);
  flatbuffers::Offset<DMLResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DMLResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DMLResponse> CreateDMLResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> logicalPlan = 0) {
  DMLResponseBuilder builder_(_fbb);
  builder_.add_logicalPlan(logicalPlan);
  return builder_.Finish();
}

inline flatbuffers::Offset<DMLResponse> CreateDMLResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *logicalPlan = nullptr) {
  return blazingdb::protocol::calcite::CreateDMLResponse(
      _fbb,
      logicalPlan ? _fbb.CreateString(logicalPlan) : 0);
}

struct DDLResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DDLResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DDLResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLResponseBuilder &operator=(const DDLResponseBuilder &);
  flatbuffers::Offset<DDLResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLResponse> CreateDDLResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DDLResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

}  // namespace calcite

namespace orchestrator {

struct AuthResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCESSTOKEN = 4
  };
  uint64_t accessToken() const {
    return GetField<uint64_t>(VT_ACCESSTOKEN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ACCESSTOKEN) &&
           verifier.EndTable();
  }
};

struct AuthResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accessToken(uint64_t accessToken) {
    fbb_.AddElement<uint64_t>(AuthResponse::VT_ACCESSTOKEN, accessToken, 0);
  }
  explicit AuthResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthResponseBuilder &operator=(const AuthResponseBuilder &);
  flatbuffers::Offset<AuthResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AuthResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuthResponse> CreateAuthResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t accessToken = 0) {
  AuthResponseBuilder builder_(_fbb);
  builder_.add_accessToken(accessToken);
  return builder_.Finish();
}

struct DMLResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULTTOKEN = 4
  };
  uint64_t resultToken() const {
    return GetField<uint64_t>(VT_RESULTTOKEN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RESULTTOKEN) &&
           verifier.EndTable();
  }
};

struct DMLResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_resultToken(uint64_t resultToken) {
    fbb_.AddElement<uint64_t>(DMLResponse::VT_RESULTTOKEN, resultToken, 0);
  }
  explicit DMLResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DMLResponseBuilder &operator=(const DMLResponseBuilder &);
  flatbuffers::Offset<DMLResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DMLResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DMLResponse> CreateDMLResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t resultToken = 0) {
  DMLResponseBuilder builder_(_fbb);
  builder_.add_resultToken(resultToken);
  return builder_.Finish();
}

struct DDLResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DDLResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DDLResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDLResponseBuilder &operator=(const DDLResponseBuilder &);
  flatbuffers::Offset<DDLResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDLResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDLResponse> CreateDDLResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DDLResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

}  // namespace orchestrator

namespace interpreter {

struct NodeConnectionInformation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PATH = 4,
    VT_TYPE = 6
  };
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  NodeConnectionType type() const {
    return static_cast<NodeConnectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.Verify(path()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct NodeConnectionInformationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(NodeConnectionInformation::VT_PATH, path);
  }
  void add_type(NodeConnectionType type) {
    fbb_.AddElement<int8_t>(NodeConnectionInformation::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit NodeConnectionInformationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeConnectionInformationBuilder &operator=(const NodeConnectionInformationBuilder &);
  flatbuffers::Offset<NodeConnectionInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodeConnectionInformation>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodeConnectionInformation> CreateNodeConnectionInformation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    NodeConnectionType type = NodeConnectionType_TPC) {
  NodeConnectionInformationBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeConnectionInformation> CreateNodeConnectionInformationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    NodeConnectionType type = NodeConnectionType_TPC) {
  return blazingdb::protocol::interpreter::CreateNodeConnectionInformation(
      _fbb,
      path ? _fbb.CreateString(path) : 0,
      type);
}

struct ExecutePlanResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULTTOKEN = 4,
    VT_CONNECTIONINFO = 6
  };
  uint64_t resultToken() const {
    return GetField<uint64_t>(VT_RESULTTOKEN, 0);
  }
  const NodeConnectionInformation *connectionInfo() const {
    return GetPointer<const NodeConnectionInformation *>(VT_CONNECTIONINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RESULTTOKEN) &&
           VerifyOffset(verifier, VT_CONNECTIONINFO) &&
           verifier.VerifyTable(connectionInfo()) &&
           verifier.EndTable();
  }
};

struct ExecutePlanResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_resultToken(uint64_t resultToken) {
    fbb_.AddElement<uint64_t>(ExecutePlanResponse::VT_RESULTTOKEN, resultToken, 0);
  }
  void add_connectionInfo(flatbuffers::Offset<NodeConnectionInformation> connectionInfo) {
    fbb_.AddOffset(ExecutePlanResponse::VT_CONNECTIONINFO, connectionInfo);
  }
  explicit ExecutePlanResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExecutePlanResponseBuilder &operator=(const ExecutePlanResponseBuilder &);
  flatbuffers::Offset<ExecutePlanResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutePlanResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutePlanResponse> CreateExecutePlanResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t resultToken = 0,
    flatbuffers::Offset<NodeConnectionInformation> connectionInfo = 0) {
  ExecutePlanResponseBuilder builder_(_fbb);
  builder_.add_resultToken(resultToken);
  builder_.add_connectionInfo(connectionInfo);
  return builder_.Finish();
}

struct BlazingMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATUS = 4,
    VT_MESSAGE = 6,
    VT_TIME = 8,
    VT_ROWS = 10
  };
  const flatbuffers::String *status() const {
    return GetPointer<const flatbuffers::String *>(VT_STATUS);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  int32_t rows() const {
    return GetField<int32_t>(VT_ROWS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.Verify(status()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyField<int32_t>(verifier, VT_ROWS) &&
           verifier.EndTable();
  }
};

struct BlazingMetadataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(flatbuffers::Offset<flatbuffers::String> status) {
    fbb_.AddOffset(BlazingMetadata::VT_STATUS, status);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(BlazingMetadata::VT_MESSAGE, message);
  }
  void add_time(double time) {
    fbb_.AddElement<double>(BlazingMetadata::VT_TIME, time, 0.0);
  }
  void add_rows(int32_t rows) {
    fbb_.AddElement<int32_t>(BlazingMetadata::VT_ROWS, rows, 0);
  }
  explicit BlazingMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlazingMetadataBuilder &operator=(const BlazingMetadataBuilder &);
  flatbuffers::Offset<BlazingMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlazingMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlazingMetadata> CreateBlazingMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> status = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    double time = 0.0,
    int32_t rows = 0) {
  BlazingMetadataBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_rows(rows);
  builder_.add_message(message);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlazingMetadata> CreateBlazingMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *status = nullptr,
    const char *message = nullptr,
    double time = 0.0,
    int32_t rows = 0) {
  return blazingdb::protocol::interpreter::CreateBlazingMetadata(
      _fbb,
      status ? _fbb.CreateString(status) : 0,
      message ? _fbb.CreateString(message) : 0,
      time,
      rows);
}

struct GetResultResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_METADATA = 4,
    VT_COLUMNS = 6,
    VT_COLUMNNAMES = 8
  };
  const BlazingMetadata *metadata() const {
    return GetPointer<const BlazingMetadata *>(VT_METADATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>> *columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>> *>(VT_COLUMNS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columnNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNNAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.Verify(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           VerifyOffset(verifier, VT_COLUMNNAMES) &&
           verifier.Verify(columnNames()) &&
           verifier.VerifyVectorOfStrings(columnNames()) &&
           verifier.EndTable();
  }
};

struct GetResultResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_metadata(flatbuffers::Offset<BlazingMetadata> metadata) {
    fbb_.AddOffset(GetResultResponse::VT_METADATA, metadata);
  }
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>>> columns) {
    fbb_.AddOffset(GetResultResponse::VT_COLUMNS, columns);
  }
  void add_columnNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames) {
    fbb_.AddOffset(GetResultResponse::VT_COLUMNNAMES, columnNames);
  }
  explicit GetResultResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetResultResponseBuilder &operator=(const GetResultResponseBuilder &);
  flatbuffers::Offset<GetResultResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetResultResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetResultResponse> CreateGetResultResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<BlazingMetadata> metadata = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>>> columns = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columnNames = 0) {
  GetResultResponseBuilder builder_(_fbb);
  builder_.add_columnNames(columnNames);
  builder_.add_columns(columns);
  builder_.add_metadata(metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetResultResponse> CreateGetResultResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<BlazingMetadata> metadata = 0,
    const std::vector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>> *columns = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columnNames = nullptr) {
  return blazingdb::protocol::interpreter::CreateGetResultResponse(
      _fbb,
      metadata,
      columns ? _fbb.CreateVector<flatbuffers::Offset<blazingdb::protocol::gdf::gdf_column_handler>>(*columns) : 0,
      columnNames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columnNames) : 0);
}

}  // namespace interpreter

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATUS = 4,
    VT_PAYLOAD = 6
  };
  Status status() const {
    return static_cast<Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  const flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.Verify(payload()) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(Status status) {
    fbb_.AddElement<int8_t>(Response::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(Response::VT_PAYLOAD, payload);
  }
  explicit ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    Status status = Status_Error,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response> CreateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Status status = Status_Error,
    const std::vector<uint8_t> *payload = nullptr) {
  return blazingdb::protocol::CreateResponse(
      _fbb,
      status,
      payload ? _fbb.CreateVector<uint8_t>(*payload) : 0);
}

struct ResponseError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERRORS = 4
  };
  const flatbuffers::String *errors() const {
    return GetPointer<const flatbuffers::String *>(VT_ERRORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERRORS) &&
           verifier.Verify(errors()) &&
           verifier.EndTable();
  }
};

struct ResponseErrorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_errors(flatbuffers::Offset<flatbuffers::String> errors) {
    fbb_.AddOffset(ResponseError::VT_ERRORS, errors);
  }
  explicit ResponseErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseErrorBuilder &operator=(const ResponseErrorBuilder &);
  flatbuffers::Offset<ResponseError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResponseError>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResponseError> CreateResponseError(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> errors = 0) {
  ResponseErrorBuilder builder_(_fbb);
  builder_.add_errors(errors);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResponseError> CreateResponseErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *errors = nullptr) {
  return blazingdb::protocol::CreateResponseError(
      _fbb,
      errors ? _fbb.CreateString(errors) : 0);
}

namespace calcite {

}  // namespace calcite

namespace orchestrator {

}  // namespace orchestrator

namespace gdf {

}  // namespace gdf

namespace orchestrator {

}  // namespace orchestrator

namespace interpreter {

}  // namespace interpreter

namespace calcite {

}  // namespace calcite

namespace orchestrator {

}  // namespace orchestrator

namespace interpreter {

}  // namespace interpreter

}  // namespace protocol
}  // namespace blazingdb

#endif  // FLATBUFFERS_GENERATED_ALL_H_
